<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>希染</title>
  
  <subtitle>愿你走过半生，归来仍是少年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangXin1538.github.io/"/>
  <updated>2019-06-03T09:24:45.291Z</updated>
  <id>http://huangXin1538.github.io/</id>
  
  <author>
    <name>希染</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何使用pixi制作&#39;打飞机&#39;小游戏</title>
    <link href="http://huangXin1538.github.io/2019/05/30/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8pixi%E5%88%B6%E4%BD%9C%E2%80%98%E6%89%93%E9%A3%9E%E6%9C%BA%E2%80%99%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>http://huangXin1538.github.io/2019/05/30/如何使用pixi制作‘打飞机’小游戏/</id>
    <published>2019-05-30T02:54:37.000Z</published>
    <updated>2019-06-03T09:24:45.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是pixi-js"><a href="#什么是pixi-js" class="headerlink" title="什么是pixi.js"></a>什么是pixi.js</h2><p>Pixi.js使用WebGL，是一个超快的HTML5 2D渲染引擎。作为一个Javascript的2D渲染器，Pixi.js的目标是提供一个快速的、轻量级而且是兼任所有设备的2D库。提供无缝 Canvas 回退，支持主流浏览器，包括桌面和移动。 Pixi渲染器可以开发者享受到硬件加速，但并不需要了解WebGL。</p><h2 id="如何引入pixi-js"><a href="#如何引入pixi-js" class="headerlink" title="如何引入pixi.js"></a>如何引入pixi.js</h2><p>1.安装模块<br>代码中引入：import * as PIXI from ‘pixi.js’;<br>2.cdn</p><script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script><h2 id="创建pixi实例完整流程"><a href="#创建pixi实例完整流程" class="headerlink" title="创建pixi实例完整流程"></a>创建pixi实例完整流程</h2><p>1.创建一个应用(application)(包含舞台stage)<br>2.加载资源（loader）<br>3.创建游戏场景<br>4.将场景插入舞台(addchild)<br>5.把画布插入dom（append）<br>6.创建精灵（sprite）<br>7.把精灵加入画布（addchild）<br>8.刷新舞台（ticker）<br>9.游戏结束，销毁应用（destroy）</p><h2 id="1-创建应用"><a href="#1-创建应用" class="headerlink" title="1.创建应用"></a>1.创建应用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gameApp = <span class="keyword">new</span> PIXI.Application(&#123;</span><br><span class="line">    width: xxxx,</span><br><span class="line">    height: xxxx,</span><br><span class="line">    antialiasing: <span class="literal">true</span>, <span class="comment">// 抗锯齿</span></span><br><span class="line">    transparent: <span class="literal">false</span>, <span class="comment">// 背景透明</span></span><br><span class="line">    resolution: <span class="number">2</span> <span class="comment">// 渲染倍数，避免模糊</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-加载资源"><a href="#2-加载资源" class="headerlink" title="2.加载资源"></a>2.加载资源</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loader = <span class="keyword">new</span> PIXI.Loader();</span><br><span class="line">loader</span><br><span class="line">    .add(<span class="string">'bg'</span>, <span class="string">'img/bg.jpg'</span>)</span><br><span class="line">    .....</span><br><span class="line">    .load(<span class="function">(<span class="params">loader, resources</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 加载完毕回调</span></span><br><span class="line">      setUp(); <span class="comment">//执行创建精灵等操作</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-创建游戏场景并插入舞台"><a href="#3-4-创建游戏场景并插入舞台" class="headerlink" title="3/4.创建游戏场景并插入舞台"></a>3/4.创建游戏场景并插入舞台</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gameScene = <span class="keyword">new</span> PIXI.Container();</span><br><span class="line">gameScene.width = xxx;</span><br><span class="line">gameScene.height = xxx;</span><br><span class="line">gameApp.stage.addchild(gameScene);</span><br></pre></td></tr></table></figure><h2 id="5-把画布插入dom"><a href="#5-把画布插入dom" class="headerlink" title="5.把画布插入dom"></a>5.把画布插入dom</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>).appendChild(gameApp.view);</span><br></pre></td></tr></table></figure><h2 id="6-创建精灵并插入场景"><a href="#6-创建精灵并插入场景" class="headerlink" title="6.创建精灵并插入场景"></a>6.创建精灵并插入场景</h2><p>首先，为了方便的设定精灵宽高，声明两个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWidth</span> (<span class="params">precent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> w = <span class="built_in">document</span>.body.clientWidth &gt; <span class="number">720</span> ? <span class="number">720</span> : <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">  <span class="keyword">return</span> (precent / <span class="number">50</span>) * w / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeight</span> (<span class="params">precent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  <span class="keyword">return</span> (precent / <span class="number">50</span>) * h / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.背景<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bg = <span class="keyword">new</span> PIXI.Sprite(resources.bg.texture);</span><br><span class="line">bg.width = xxx;</span><br><span class="line">bg.height = xxx;</span><br><span class="line">bg.x = xxx;</span><br><span class="line">bg.y = xxx;</span><br><span class="line">gameScene.addchild(bg)</span><br></pre></td></tr></table></figure></p><p>2.飞机<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> plane = <span class="keyword">new</span> PIXI.Sprite(resources.plane.texture);</span><br><span class="line">plane.width = xxx;</span><br><span class="line">plane.height = xxx;</span><br><span class="line">plane.x = xxx;</span><br><span class="line">plane.y = xxx;</span><br><span class="line">gameScene.addchild(plane)</span><br></pre></td></tr></table></figure></p><p>给飞机添加拖动事件，让飞机跟着手指移动。<br>给飞机添加射击事件，在ticker中调用，使飞机一直发射子弹<br>3.障碍物<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obstacle  = <span class="keyword">new</span> PIXI.Sprite(resources.obstacle.texture);</span><br><span class="line">obstacle.width = xxx;</span><br><span class="line">obstacle.height = xxx;</span><br><span class="line">obstacle.x = xxx;</span><br><span class="line">obstacle.y = xxx;</span><br><span class="line">gameScene.addchild(obstacle)</span><br></pre></td></tr></table></figure></p><p>这种只是最基础的做法，如果有稍微多一点的需求，例如，碰撞检测的区域，和纹理图大小不一样，就需要<br>将障碍物纹理、碰撞区域、爆炸动画，都放入一个container内，碰撞区域push进入obstacles数组，去和子弹飞机做碰撞检测<br>障碍物的飞行，使用tween.js,初始化时候，设置好起点终点，在ticker中update就可以像目的地移动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="keyword">new</span> PIXI.Container();</span><br><span class="line"><span class="comment">// 图案</span></span><br><span class="line"><span class="keyword">let</span> obstacle = <span class="keyword">new</span> PIXI.Sprite(texture.obstacle.texture);</span><br><span class="line">obstacle.name = <span class="string">'obstacle'</span>;</span><br><span class="line">obstacle.width = getWidth(<span class="number">30</span>);</span><br><span class="line">obstacle.height = getWidth(<span class="number">30</span>);</span><br><span class="line">obstacle.x = <span class="number">0</span>;</span><br><span class="line">obstacle.y = <span class="number">0</span>;</span><br><span class="line">obstacle.anchor.set(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// 碰撞区域</span></span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> PIXI.Sprite();</span><br><span class="line">circle.width = obstacle.width * <span class="number">0.5</span>;</span><br><span class="line">circle.height = circle.width;</span><br><span class="line">circle.name = <span class="string">'circle'</span>;</span><br><span class="line">circle.circular = <span class="literal">true</span>;</span><br><span class="line">circle.x = -circle.width*<span class="number">0.5</span>;</span><br><span class="line">circle.y = -circle.height*<span class="number">0.5</span>;</span><br><span class="line">container.addChild(circle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文字</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="keyword">new</span> PIXI.Text(<span class="string">'哈哈'</span>, &#123;</span><br><span class="line">  fontSize: obstacle.width * <span class="number">0.13</span>,</span><br><span class="line">  fill: <span class="string">'#fff'</span></span><br><span class="line">&#125;);</span><br><span class="line">text.x = - text.width*<span class="number">0.5</span>;</span><br><span class="line">text.y = - text.height*<span class="number">0.5</span>;</span><br><span class="line">container.addChild(text);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 爆炸效果</span></span><br><span class="line"><span class="keyword">let</span> fireClip = [</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">23</span>; i++) &#123;</span><br><span class="line">  fireClip.push(texture.boom.textures[<span class="string">'boom'</span> + i + <span class="string">'.png'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boom = <span class="keyword">new</span> PIXI.AnimatedSprite(fireClip);</span><br><span class="line">boom.width = obstacle.width * <span class="number">2.5</span>;</span><br><span class="line">boom.height = obstacle.height * <span class="number">2.5</span>;</span><br><span class="line">boom.x = -boom.width * <span class="number">0.5</span>;</span><br><span class="line">boom.y = -boom.height * <span class="number">0.5</span>;</span><br><span class="line">boom.name = <span class="string">'boom'</span>;</span><br><span class="line">boom.loop = <span class="literal">false</span>;</span><br><span class="line">container.addChild(boom);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">container.addChild(obstacle);</span><br><span class="line">container.addChild(circle);</span><br><span class="line">container.x = getWidth(<span class="built_in">Math</span>.random()*<span class="number">100</span>);</span><br><span class="line">container.y = -obstacle.height;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 位移设定</span></span><br><span class="line"><span class="keyword">let</span> tween = <span class="keyword">new</span> TWEEN.Tween(container)</span><br><span class="line">  .to(</span><br><span class="line">    &#123;</span><br><span class="line">      x: getWidth(<span class="built_in">Math</span>.random() * <span class="number">100</span>),</span><br><span class="line">      y: getHeight(<span class="number">100</span>) + obstacle.height,</span><br><span class="line">    &#125;,</span><br><span class="line">    obstacleTime <span class="comment">// tween持续时间</span></span><br><span class="line">  )</span><br><span class="line">  .easing(TWEEN.Easing.Linear.None)</span><br><span class="line">  .onComplete(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 到底</span></span><br><span class="line">    container.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line">tween.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转设定</span></span><br><span class="line"><span class="keyword">let</span> tween2 = <span class="keyword">new</span> TWEEN.Tween(obstacle)</span><br><span class="line">  .to(</span><br><span class="line">    &#123;</span><br><span class="line">      rotation: <span class="number">-20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    obstacleTime <span class="comment">// tween持续时间</span></span><br><span class="line">  )</span><br><span class="line">  .easing(TWEEN.Easing.Linear.None)</span><br><span class="line">  .onComplete(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;);</span><br><span class="line">tween2.start();</span><br><span class="line"><span class="comment">// 插入场景</span></span><br><span class="line">container.tween = tween;</span><br><span class="line">obstacles.push(circle);</span><br><span class="line">tweens.push(tween);</span><br><span class="line">gameScene.addChild(container);</span><br></pre></td></tr></table></figure><h2 id="7-更新舞台"><a href="#7-更新舞台" class="headerlink" title="7.更新舞台"></a>7.更新舞台</h2><p>创建完游戏内所有元素后，开启pixi内置定时器ticker<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.ticker.add(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gameLoop();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在ticker中更新需要调用的事件，来实现游戏的动态效果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gameLoop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 生成子弹</span></span><br><span class="line">  plane.shut(gameScene, bullets);</span><br><span class="line">  <span class="comment">// 生成障碍物</span></span><br><span class="line">  createobstacle(gameScene, texture, obstacles, TWEEN, tweens);</span><br><span class="line">  <span class="comment">// 子弹逻辑处理</span></span><br><span class="line">  bulletsEvents();</span><br><span class="line">  <span class="comment">// 障碍物逻辑处理</span></span><br><span class="line">  obstaclesEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8-子弹飞机障碍物的碰撞逻辑（重点）"><a href="#8-子弹飞机障碍物的碰撞逻辑（重点）" class="headerlink" title="8.子弹飞机障碍物的碰撞逻辑（重点）"></a>8.子弹飞机障碍物的碰撞逻辑（重点）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bulletsEvents</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bullets.length;)&#123;</span><br><span class="line">    <span class="keyword">let</span> hit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> o = <span class="number">0</span>; o &lt; obstacles.length; ) &#123;</span><br><span class="line">        <span class="comment">// 子弹与障碍物碰撞检测</span></span><br><span class="line">      <span class="keyword">if</span>(hitTest(obstacles[o], bullets[i])) &#123;</span><br><span class="line">        hit = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 移除障碍物</span></span><br><span class="line">        obstaclesBoom(o)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hitTest(obstacles[o], plane))&#123;</span><br><span class="line">        <span class="comment">// 飞机与障碍物碰撞检测</span></span><br><span class="line">        <span class="keyword">let</span> _obstacle = obstacles.splice(o,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">        _obstacle.destroy();</span><br><span class="line">        gameOver();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        o++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据碰撞状态做处理</span></span><br><span class="line">    <span class="keyword">if</span>(hit)&#123;</span><br><span class="line">      <span class="comment">// 如果碰撞了</span></span><br><span class="line">      <span class="comment">// 移除当前子弹</span></span><br><span class="line">      <span class="keyword">let</span> _bullet = bullets.splice(i,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">      _bullet.destroy();</span><br><span class="line">      <span class="comment">// 加分</span></span><br><span class="line">      score ++;</span><br><span class="line">      scorePanel.text = <span class="string">'得分：'</span> + score;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 如果子弹飞出屏幕，则移除；如果没有，Y轴位移</span></span><br><span class="line">      <span class="keyword">if</span>(bullets[i].y &lt; -bullets[i].height)&#123;</span><br><span class="line">        <span class="keyword">let</span> _bullet = bullets.splice(i,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">        _bullet.destroy();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        bullets[i].y -= <span class="number">10</span>;</span><br><span class="line">        i++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先遍历子弹池，内部遍历所有障碍物，通过hitTest做碰撞检测<br>如果子弹和障碍物碰撞，子弹消失，障碍物消失/爆炸，得分+1；<br>如果飞机和障碍物碰撞，障碍物消失/爆炸，游戏结束<br>如果都没有，检测下一个子弹</p><h1 id="如果子弹自下而上，飞出屏幕，则子弹移除，否则影响性能"><a href="#如果子弹自下而上，飞出屏幕，则子弹移除，否则影响性能" class="headerlink" title="如果子弹自下而上，飞出屏幕，则子弹移除，否则影响性能"></a>如果子弹自下而上，飞出屏幕，则子弹移除，否则影响性能</h1><p>碰撞检测代码，bump通过cdn引入<br>hitTestCircleRectangle只能用于圆形和矩形的碰撞，更多方式查看PIXI官方文档<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子弹词条碰撞</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> PIXI <span class="keyword">from</span> <span class="string">'pixi.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hitTest</span> (<span class="params">r1, r2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">new</span> Bump(PIXI);</span><br><span class="line">  <span class="keyword">if</span> (b.hitTestCircleRectangle(r1, r2, <span class="literal">true</span>) !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="9-障碍物爆炸逻辑"><a href="#9-障碍物爆炸逻辑" class="headerlink" title="9.障碍物爆炸逻辑"></a>9.障碍物爆炸逻辑</h2><p>碰撞之后，根据parent属性，找到container，进而找到内部的爆炸动画，执行play()方法；<br>爆炸的同时，使纹理隐藏，形成视觉上的碰撞爆炸效果</p><p>部分代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obstaclesBoom</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> container = obstacles[o].parent;</span><br><span class="line">  <span class="keyword">let</span> _obstacle = obstacles.splice(o,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  _obstacle.destroy();</span><br><span class="line">  container.children[<span class="number">1</span>].play();</span><br><span class="line">  container.children[<span class="number">0</span>].visible = <span class="literal">false</span>;</span><br><span class="line">  container.children[<span class="number">2</span>].visible = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只是随便讲一下做法的逻辑，具体代码已上传github，地址：<a href="https://github.com/huangXin1538/pixi-aircrift-wars" target="_blank" rel="noopener">https://github.com/huangXin1538/pixi-aircrift-wars</a><br>就酱~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是pixi-js&quot;&gt;&lt;a href=&quot;#什么是pixi-js&quot; class=&quot;headerlink&quot; title=&quot;什么是pixi.js&quot;&gt;&lt;/a&gt;什么是pixi.js&lt;/h2&gt;&lt;p&gt;Pixi.js使用WebGL，是一个超快的HTML5 2D渲染引擎。作为一个
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue双向绑定原理</title>
    <link href="http://huangXin1538.github.io/2019/05/28/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>http://huangXin1538.github.io/2019/05/28/vue双向绑定原理/</id>
    <published>2019-05-28T08:05:34.000Z</published>
    <updated>2019-05-28T08:56:50.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>vue数据双向绑定通过‘数据劫持’ + 订阅发布模式实现</p><h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果</p><p>典型的有<br>1.Object.defineProperty()<br>2.es6中Proxy对象</p><p>vue2.x使用Object.defineProperty();<br>vue3.x使用Proxy;</p><h2 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h2><p>定义：对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知<br>订阅发布模式中事件统一由处理中心处理，订阅者发布者互不干扰。<br>优点：实现更多的控制，做权限处理，节流控制之类，例如：发布了很多消息，但是不是所有订阅者都要接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个处理中心</span></span><br><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">  clientList: &#123;&#125;, <span class="comment">// 订阅事件列表</span></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  on(key, fn)&#123;</span><br><span class="line">    <span class="comment">// 如果这个事件没有被订阅，那么创建一个列表用来存放事件</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.clientList[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将事件放入已有的事件列表中</span></span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  trigger(type, args)&#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.clientList[type] <span class="comment">// 拿到这个事件的所有监听</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;  <span class="comment">// 如果没有这条消息的订阅者</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在这个事件的订阅，那么遍历事件列表，触发对应监听</span></span><br><span class="line">    fns.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 可以在此处添加过滤等处理</span></span><br><span class="line">      fn(args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue中如何实现"><a href="#vue中如何实现" class="headerlink" title="vue中如何实现"></a>vue中如何实现</h2><p>利用Object.defineProperty();把内部解耦为三部分<br>Observer: 递归的监听对象上的所有属性，当属性改变时触发对应的watcher<br>watcher(观察者):当蒋婷的数据值修改时，执行相应的回调函数，更新模板内容<br>dep：链接observer和watcher，每一个observer对应一个dep,内部维护一个数组，保存与该observer相关的watcher</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;vue数据双向绑定通过‘数据劫持’ + 订阅发布模式实现&lt;/p&gt;
&lt;h2 id=&quot;数据劫持&quot;&gt;&lt;a href=&quot;#数据劫持&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js手写简单双向绑定</title>
    <link href="http://huangXin1538.github.io/2019/05/27/%E6%89%8B%E5%86%99%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://huangXin1538.github.io/2019/05/27/手写双向绑定/</id>
    <published>2019-05-27T08:23:13.000Z</published>
    <updated>2019-05-27T09:10:55.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是双向绑定"><a href="#什么是双向绑定" class="headerlink" title="什么是双向绑定"></a>什么是双向绑定</h2><p>1.当一个对象（或变量）的属性改变，那么调用这个属性地方也应该改变，模型到视图（model =&gt; view）<br>2.当调用属性的这个地方改变了这个属性（通常是一个表单元素），那么这个对象（或变量）的属性也随之改变，即视图到模型（view =&gt; model）</p><h2 id="如何实现（怎么知道对象的属性变了）"><a href="#如何实现（怎么知道对象的属性变了）" class="headerlink" title="如何实现（怎么知道对象的属性变了）"></a>如何实现（怎么知道对象的属性变了）</h2><p>Object.defineProperty 设置对象属性的描述字段里面有两个属性set(设置属性时被调用)和get（获取属性时被调用）<br>input检测属性值的改变，触发后对应修改对应的对象（或变量）<br>例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    手写一个简单双向绑定<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"model"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"modelText"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">'希染'</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> defaultName = <span class="string">'希染'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">"#model"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">"#modelText"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    input.value = user.name;</span></span><br><span class="line"><span class="undefined">    text.textContent = user.name;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 数据到视图 model =&gt; view</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.defineProperty(user,<span class="string">"name"</span>,&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">get</span>:function()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'获取user'</span>)</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">set</span>:function(val)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'修改user'</span>)</span></span><br><span class="line"><span class="undefined">        input.value = val;</span></span><br><span class="line"><span class="undefined">        text.textContent = val;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 视图到数据 view =&gt; model</span></span></span><br><span class="line"><span class="javascript">    input.addEventListener(<span class="string">'input'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">      user.name = input.value;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是双向绑定&quot;&gt;&lt;a href=&quot;#什么是双向绑定&quot; class=&quot;headerlink&quot; title=&quot;什么是双向绑定&quot;&gt;&lt;/a&gt;什么是双向绑定&lt;/h2&gt;&lt;p&gt;1.当一个对象（或变量）的属性改变，那么调用这个属性地方也应该改变，模型到视图（model =&amp;gt
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>遇到过的问题</title>
    <link href="http://huangXin1538.github.io/2019/05/21/%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://huangXin1538.github.io/2019/05/21/遇到过的问题/</id>
    <published>2019-05-21T06:25:35.000Z</published>
    <updated>2019-05-21T06:29:11.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义视频播放按钮，播放后设置播放按钮隐藏，但是切屏后返回，按钮又出现"><a href="#1-自定义视频播放按钮，播放后设置播放按钮隐藏，但是切屏后返回，按钮又出现" class="headerlink" title="1.自定义视频播放按钮，播放后设置播放按钮隐藏，但是切屏后返回，按钮又出现"></a>1.自定义视频播放按钮，播放后设置播放按钮隐藏，但是切屏后返回，按钮又出现</h2><p>原因：切屏时，视频自动暂停，触发了onpause回调，导致播放按钮出现；返回时，视频自动继续播放，没有走按钮的点击事件<br>解决：添加视频onplay监听，如果视频播放，就隐藏播放按钮</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-自定义视频播放按钮，播放后设置播放按钮隐藏，但是切屏后返回，按钮又出现&quot;&gt;&lt;a href=&quot;#1-自定义视频播放按钮，播放后设置播放按钮隐藏，但是切屏后返回，按钮又出现&quot; class=&quot;headerlink&quot; title=&quot;1.自定义视频播放按钮，播放后设置播
      
    
    </summary>
    
    
      <category term="bug" scheme="http://huangXin1538.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>js数组去重方式</title>
    <link href="http://huangXin1538.github.io/2019/05/14/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://huangXin1538.github.io/2019/05/14/js数组去重方式/</id>
    <published>2019-05-14T09:54:17.000Z</published>
    <updated>2019-05-24T07:32:52.609Z</updated>
    
    <content type="html"><![CDATA[<p>Set：数据结构，类似数组，成员唯一<br>…：（展开/剩余）运算符，展开数组和对象；</p><p>…使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展开</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...a);</span><br><span class="line">输出： <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>Set使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,1,1,1,2,2,2]</span><br><span class="line">let b = new Set(a)</span><br><span class="line"></span><br><span class="line">输出b: Set&#123;1,2&#125;</span><br></pre></td></tr></table></figure></p><p>结合两者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a = [...new <span class="built_in">Set</span>(a)];</span><br><span class="line">输出 a = [<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p><p>首先 new Set(a) 为 Set{1,2}<br>然后…将 new Set(a)展开，为: 1 2<br>最后，放入a中，实现去重</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Set：数据结构，类似数组，成员唯一&lt;br&gt;…：（展开/剩余）运算符，展开数组和对象；&lt;/p&gt;
&lt;p&gt;…使用&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>es6解构赋值</title>
    <link href="http://huangXin1538.github.io/2019/04/18/es6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://huangXin1538.github.io/2019/04/18/es6解构赋值/</id>
    <published>2019-04-18T03:56:41.000Z</published>
    <updated>2019-05-14T10:14:08.302Z</updated>
    
    <content type="html"><![CDATA[<p>基本用法：es6允许按照一定模式，从对象和数组中提取值，对变量进行赋值，被称为解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a=1;b=2;c=3</span></span><br></pre></td></tr></table></figure><p>只要等号两边的模式相同，左边的变量就会被赋予对应的值</p><p>Set 结构，也可以使用数组的解构赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure></p><p>注意点：<br>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></p><p> JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误<br>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure></p><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。<br>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本用法：es6允许按照一定模式，从对象和数组中提取值，对变量进行赋值，被称为解构赋值&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="es6" scheme="http://huangXin1538.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>重绘和回流</title>
    <link href="http://huangXin1538.github.io/2019/04/17/%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/"/>
    <id>http://huangXin1538.github.io/2019/04/17/重绘和回流/</id>
    <published>2019-04-17T09:56:47.000Z</published>
    <updated>2019-04-17T10:03:50.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少</p><p>常见重绘操作有：<br>1.改变元素颜色<br>2.改变元素背景色<br>3.。。。。。。</p><h2 id="回流（重排）"><a href="#回流（重排）" class="headerlink" title="回流（重排）"></a>回流（重排）</h2><p>当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新计算，计算后还需要重新布局页面，因此是较重的操作。</p><p>常见回流操作有：<br>1.页面初次渲染<br>2.浏览器窗口大小改变<br>3.元素尺寸、位置、内容发生改变<br>4.元素字体大小变化<br>5.添加或删除可见的DOM<br>6.激活css伪类（：hover）<br>7.。。。。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回流必定触发重绘，重绘不一定触发回流。回流开销较大。</p><p>如何避免大量使用重绘和回流</p><p>1.避免频繁操作样式，可汇总后统一修改<br>2.尽量使用class进行样式修改，而不是直接插入样式<br>3.减少dom操作。可使用字符串一次插入</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重绘&quot;&gt;&lt;a href=&quot;#重绘&quot; class=&quot;headerlink&quot; title=&quot;重绘&quot;&gt;&lt;/a&gt;重绘&lt;/h2&gt;&lt;p&gt;当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少&lt;/p&gt;
&lt;p&gt;常见重绘操作
      
    
    </summary>
    
    
      <category term="优化" scheme="http://huangXin1538.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>js节流和防抖</title>
    <link href="http://huangXin1538.github.io/2019/04/17/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"/>
    <id>http://huangXin1538.github.io/2019/04/17/节流和防抖/</id>
    <published>2019-04-17T09:36:10.000Z</published>
    <updated>2019-04-17T09:54:11.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>在进行窗口的 resize、scroll、输入框内容验证、touchmove 等操作时，如果事件处理函数调用的频率无限制，会加重浏览器负担，甚至卡死。导致用户体验很糟糕。<br>此时可以采用 debounce（防抖）和 throttle（节流）的方式减少调用频率，同时不影响实际效果</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次。如果设定的事件到来之前，又触发了事件，就重新开始延时<br>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout !== <span class="literal">null</span>) clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(fn, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。<br>例如。当持续触发 scroll 事件时，并不立即执行回调，每隔 1s 才会执行一次</p><h3 id="1-时间戳方式实现"><a href="#1-时间戳方式实现" class="headerlink" title="1.时间戳方式实现"></a>1.时间戳方式实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h3 id="2-定时器方式实现"><a href="#2-定时器方式实现" class="headerlink" title="2.定时器方式实现"></a>2.定时器方式实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数防抖：讲几次操作合为一次操作进行。原理是维护一个定时器，规定在delay时间后触发，但是在delay时间内再次触发，就会取消之前的定时器重新设置。这样一来，只有最后一次才能触发</p><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数</p><p>区别：<br>  函数节流不管事件触发多频繁，都会保证在规定时间内一定会触发一次函数<br>  防抖只是在最后一次事件后才触发一次函数<br>  比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次ajax，而不是在用户停下时才去请求。这样的场景适合用节流<br>  页面缩放修改rem设定，适合用防抖</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;意义&quot;&gt;&lt;a href=&quot;#意义&quot; class=&quot;headerlink&quot; title=&quot;意义&quot;&gt;&lt;/a&gt;意义&lt;/h2&gt;&lt;p&gt;在进行窗口的 resize、scroll、输入框内容验证、touchmove 等操作时，如果事件处理函数调用的频率无限制，会加重浏览器负担，
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js字符串方法</title>
    <link href="http://huangXin1538.github.io/2019/04/09/js%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <id>http://huangXin1538.github.io/2019/04/09/js字符串方法/</id>
    <published>2019-04-09T09:18:17.000Z</published>
    <updated>2019-04-09T09:37:25.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h2><p>返回指定索引位置的字符</p><h2 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h2><p>返回指定索引位置的Unicode值</p><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>连接两个或多个字符串，返回连接后的字符串</p><h2 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode()"></a>fromCharCode()</h2><p>将Unicode转换为字符串</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h2><p>返回字符串中指定字符第一次出现的位置</p><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h2><p>最后一次出现的位置</p><h2 id="localeCompare"><a href="#localeCompare" class="headerlink" title="localeCompare()"></a>localeCompare()</h2><p>用本地特定的顺序来比较两个字符串</p><h2 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h2><p>找到一个或多个正则表达式的匹配</p><h2 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h2><p>替换与正则表达式匹配的字符串</p><h2 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h2><p>检索与正则表达式匹配的值</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>提取字符串的片段，并在新的字符串中返回被提取的部分</p><h2 id="split-分隔符"><a href="#split-分隔符" class="headerlink" title="split(分隔符)"></a>split(分隔符)</h2><p>按分隔符把字符串分割为数组</p><h2 id="substr-start-length"><a href="#substr-start-length" class="headerlink" title="substr(start,length)"></a>substr(start,length)</h2><p>从起始索引号提取字符串中指定数目的字符</p><h2 id="substring-from-to"><a href="#substring-from-to" class="headerlink" title="substring(from,to)"></a>substring(from,to)</h2><p>提取字符串中两个指定的索引号之间的字符</p><h2 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h2><p>‘ABC’.toLocaleLowerCase() //abc<br>转为小写,不会改变原字符串</p><h2 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h2><p>‘abc’.toLocaleLowerCase() //ABC<br>转为大写,不会改变原字符串</p><h2 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h2><p>删除字符串首尾空格<br>str.trim();<br>不会改变原字符串</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;charAt&quot;&gt;&lt;a href=&quot;#charAt&quot; class=&quot;headerlink&quot; title=&quot;charAt()&quot;&gt;&lt;/a&gt;charAt()&lt;/h2&gt;&lt;p&gt;返回指定索引位置的字符&lt;/p&gt;
&lt;h2 id=&quot;charCodeAt&quot;&gt;&lt;a href=&quot;#char
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js数组方法</title>
    <link href="http://huangXin1538.github.io/2019/04/09/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>http://huangXin1538.github.io/2019/04/09/js数组方法/</id>
    <published>2019-04-09T06:43:17.000Z</published>
    <updated>2019-04-09T08:52:03.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="concat-合并"><a href="#concat-合并" class="headerlink" title="concat 合并"></a>concat 合并</h2><p>arr1.concat(arr2)</p><h2 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h2><p>该方法返回一个新的Array Iterator（迭代器）对象，该对象包含数组中每个索引对应的键/值对<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">var</span> iterator = a.entries()</span><br><span class="line"><span class="built_in">console</span>.log(iterator) <span class="comment">// Array Iterator&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">// [0,'a']</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> iterator)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[0,'a']</span></span><br><span class="line"><span class="comment">//[1,'b']</span></span><br><span class="line"><span class="comment">//[2,'c']</span></span><br></pre></td></tr></table></figure></p><h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><p>array.every(function(currentValue,index,arr), thisValue)<br>检测数组中每个元素是否符合筛选条件；<br>参数1：function(每一个元素) 必传<br>    2：thisValue 可选<br>返回 true/false</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p>array.fill(value, start, end)<br>将数组中元素都替换成固定值</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>过滤出符合条件的元素，组成新数组并返回<br>array.filter(function(currentValue,index,arr), thisValue)</p><p>1.不会对空数组检测<br>2.不会改变原数组</p><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><p>获取数组中第一个符合条件的值<br>array.find(function(currentValue, index, arr),thisValue)</p><p>找不到返回undefined</p><h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h2><p>获取数组中第一个符合条件的值，返回所在位置<br>array.findIndex(function(currentValue, index, arr),thisValue)<br>找不到返回-1</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p>遍历数组<br>array.forEach(function(currentValue, index, arr), thisValue)</p><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p>判断数组中是否包含一个指定的值<br>arr.includes(searchElement, fromIndex)</p><p>返回true/false</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h2><p>array.indexOf(item,start)<br>返回数组中某个指定元素的位置<br>找不到返回-1</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>array.join(分隔符); //不传就是没有分隔<br>数组中所有元素放入一个字符串并返回</p><h2 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h2><p>从数组创建一个包含数组键的可迭代对象<br>array.keys();<br>返回： Array Iterator<br>for(let a of array.keys()){<br>    console.log(a)<br>}<br>log出索引值</p><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h2><p>获取数组中第一个符合条件的值，返回所在位置，倒序<br>array.lastIndexOf();</p><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值<br>array.map(function(currentValue,index,arr), thisValue)</p><h2 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h2><p>删除数组中最后一个元素，并返回<br>array.pop();</p><h2 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h2><p>向数组末添加一个或多个元素，返回新长度<br>array.push(newelement1,newelement2,….,newelementX)</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><p>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值<br>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)<br>高阶函数，可用于compose</p><h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h2><p>从右边开始reduce</p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><p>翻转数组并返回</p><h2 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h2><p>删除数组中第一个元素，并返回该元素<br>会改变数组长度</p><h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><p>array.splice(index,howmany,item1,…..,itemX)<br>按照指定位置，删除数组中的元素；第三个以后参数，可以在删除位置添加元素</p><h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><p>用法同every()，区别为every：每一项都为true，才返回true;some: 任一项为true，就返回true</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p>array.sort(sortfunction(a,b))<br>对数组进行排序,a,b为前后两个元素，return a&gt;b;升序，return a&lt; b 降序；</p><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>array.slice(start,end);<br>从已有数组中选出指定元素，并放进一个数组返回<br>不会改变原数组</p><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>[0,1].toString = ‘0,1’</p><h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h2><p>想数组开头添加一个或多个元素，返回新长度<br>arrayObject.unshift(newelement1,newelement2,….,newelementX)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;concat-合并&quot;&gt;&lt;a href=&quot;#concat-合并&quot; class=&quot;headerlink&quot; title=&quot;concat 合并&quot;&gt;&lt;/a&gt;concat 合并&lt;/h2&gt;&lt;p&gt;arr1.concat(arr2)&lt;/p&gt;
&lt;h2 id=&quot;entries&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js数据类型</title>
    <link href="http://huangXin1538.github.io/2019/04/09/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://huangXin1538.github.io/2019/04/09/js数据类型/</id>
    <published>2019-04-09T06:40:31.000Z</published>
    <updated>2019-04-09T06:42:59.946Z</updated>
    
    <content type="html"><![CDATA[<p>基本类型：String（字符型）、Number（数字型）、Boolean(布尔型)、undefined、null</p><p>引用类型：Object（包括function/array）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本类型：String（字符型）、Number（数字型）、Boolean(布尔型)、undefined、null&lt;/p&gt;
&lt;p&gt;引用类型：Object（包括function/array）&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js闭包</title>
    <link href="http://huangXin1538.github.io/2019/04/02/20190402-2/"/>
    <id>http://huangXin1538.github.io/2019/04/02/20190402-2/</id>
    <published>2019-04-02T08:26:57.000Z</published>
    <updated>2019-04-09T03:03:55.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js-内存回收机制-和-闭包定义"><a href="#js-内存回收机制-和-闭包定义" class="headerlink" title="js 内存回收机制 和 闭包定义"></a>js 内存回收机制 和 闭包定义</h2><p>一个函数在执行开始的时候，会给其中定义的变量划分内存空间保存，以备后面的语句所用，等到函数执行完毕，这些变量就被认为是无用的，对应的空间会被收回。</p><p>下次再执行这个函数的时候，所有的变量又回到了最初的的状态，重新赋值使用。</p><p>但是当一个函数内部又嵌套了一个函数，而这个函数是有可能在外部被调用到的。并且这个内部函数又使用了外部函数的某些变量的话，这种内存回收机制就会出现问题。如果在外部函数返回后，又直接调用了内部函数。那么内部函数就无法读取他所需要的外部函数中的变量的值了。</p><p>所以js解释器在遇到函数定义的时候会自动把函数和他可能使用的变量一起保存下来。也就形成一个闭包。<br>这些变量不会被内存回收，只有当内部的函数不可能被调用以后（例如被删除、没有了指针），才会销毁这个闭包，而没有任何一个闭包引用的变量才会被下一次内存回收启动时回收。</p><h2 id="闭包特性"><a href="#闭包特性" class="headerlink" title="闭包特性"></a>闭包特性</h2><p> 1.函数嵌套函数<br> 2.函数内部可以引用外部的参数和变量<br> 3.参数和变量不会被回收</p><h2 id="闭包好处"><a href="#闭包好处" class="headerlink" title="闭包好处"></a>闭包好处</h2><p> 1.希望一个变量长期存储在内存中<br> 2.避免全局变量的污染<br> 3.私有成员的存在</p><h2 id="闭包坏处"><a href="#闭包坏处" class="headerlink" title="闭包坏处"></a>闭包坏处</h2><p> 1.常驻内存，增加内存使用量<br> 2.使用不当造成内存泄漏（一块被分配的内存既不能使用，又不能回收）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js-内存回收机制-和-闭包定义&quot;&gt;&lt;a href=&quot;#js-内存回收机制-和-闭包定义&quot; class=&quot;headerlink&quot; title=&quot;js 内存回收机制 和 闭包定义&quot;&gt;&lt;/a&gt;js 内存回收机制 和 闭包定义&lt;/h2&gt;&lt;p&gt;一个函数在执行开始的时候，会
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js变量提升</title>
    <link href="http://huangXin1538.github.io/2019/04/02/20190402-1/"/>
    <id>http://huangXin1538.github.io/2019/04/02/20190402-1/</id>
    <published>2019-04-02T08:10:29.000Z</published>
    <updated>2019-05-24T07:17:37.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量进入作用域方式"><a href="#变量进入作用域方式" class="headerlink" title="变量进入作用域方式"></a>变量进入作用域方式</h2><p>1.语言内置：所有的作用域都有 this 和 arguments<br>2.形式参数：函数的形式参数会作为函数作用域的一部分<br>3.函数声明: function a(){}<br>4.变量声明：var a;</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>函数及变量的声明都将被提升到函数的最顶部</p><p>函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br><span class="line">log依次为<span class="number">5</span>，<span class="literal">undefined</span>，<span class="number">10</span>；</span><br><span class="line"></span><br><span class="line">实际执行顺序</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为a = 5,在test1内执行，所以window.a为undefined</p><p>如果直接在window下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 5;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(window.a);</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p><p>结果，5,5,10;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量进入作用域方式&quot;&gt;&lt;a href=&quot;#变量进入作用域方式&quot; class=&quot;headerlink&quot; title=&quot;变量进入作用域方式&quot;&gt;&lt;/a&gt;变量进入作用域方式&lt;/h2&gt;&lt;p&gt;1.语言内置：所有的作用域都有 this 和 arguments&lt;br&gt;2.形式参数
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>html5调起摄像头拍照</title>
    <link href="http://huangXin1538.github.io/2019/03/29/20190329-1/"/>
    <id>http://huangXin1538.github.io/2019/03/29/20190329-1/</id>
    <published>2019-03-29T06:19:23.000Z</published>
    <updated>2019-03-29T06:26:09.817Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html部分</span></span><br><span class="line">&lt;video id=<span class="string">"video"</span> width=<span class="string">"480"</span> height=<span class="string">"320"</span> controls&gt;&lt;/video&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button id=<span class="string">"capture"</span>&gt;拍照&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;canvas id=<span class="string">"canvas"</span> width=<span class="string">"480"</span> height=<span class="string">"320"</span>&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>);</span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="comment">//访问用户媒体设备的兼容方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserMedia</span>(<span class="params">constraints, success, error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (navigator.mediaDevices.getUserMedia) &#123;</span><br><span class="line">    <span class="comment">//最新的标准API</span></span><br><span class="line">    navigator.mediaDevices</span><br><span class="line">      .getUserMedia(constraints)</span><br><span class="line">      .then(success)</span><br><span class="line">      .catch(error);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.webkitGetUserMedia) &#123;</span><br><span class="line">    <span class="comment">//webkit核心浏览器</span></span><br><span class="line">    navigator.webkitGetUserMedia(constraints, success, error);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.mozGetUserMedia) &#123;</span><br><span class="line">    <span class="comment">//firfox浏览器</span></span><br><span class="line">    navigator.mozGetUserMedia(constraints, success, error);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.getUserMedia) &#123;</span><br><span class="line">    <span class="comment">//旧版API</span></span><br><span class="line">    navigator.getUserMedia(constraints, success, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//兼容webkit核心浏览器</span></span><br><span class="line">  <span class="keyword">let</span> CompatibleURL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line">  <span class="comment">//将视频流设置为video元素的源</span></span><br><span class="line">  <span class="built_in">console</span>.log(stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//video.src = CompatibleURL.createObjectURL(stream);</span></span><br><span class="line">  video.srcObject = stream;</span><br><span class="line">  video.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`访问用户媒体设备失败<span class="subst">$&#123;error.name&#125;</span>, <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  navigator.mediaDevices.getUserMedia ||</span><br><span class="line">  navigator.getUserMedia ||</span><br><span class="line">  navigator.webkitGetUserMedia ||</span><br><span class="line">  navigator.mozGetUserMedia</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">//调用用户媒体设备, 访问摄像头</span></span><br><span class="line">  getUserMedia(&#123;<span class="attr">video</span>: &#123;<span class="attr">width</span>: <span class="number">480</span>, <span class="attr">height</span>: <span class="number">320</span>&#125;&#125;, success, error);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"不支持访问用户媒体"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击拍照</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'capture'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  context.drawImage(video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">480</span>, <span class="number">320</span>);      </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="html5" scheme="http://huangXin1538.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>base64与file格式图片转换</title>
    <link href="http://huangXin1538.github.io/2019/03/26/20190326-1/"/>
    <id>http://huangXin1538.github.io/2019/03/26/20190326-1/</id>
    <published>2019-03-26T07:14:44.000Z</published>
    <updated>2019-03-29T03:55:43.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="base64转file"><a href="#base64转file" class="headerlink" title="base64转file"></a>base64转file</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoFile</span>(<span class="params">dataurl, filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//将base64转换为文件</span></span><br><span class="line">  <span class="keyword">var</span> arr = dataurl.split(<span class="string">","</span>),</span><br><span class="line">    mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>],</span><br><span class="line">    bstr = atob(arr[<span class="number">1</span>]),</span><br><span class="line">    n = bstr.length,</span><br><span class="line">    u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> File([u8arr], filename, &#123;</span><br><span class="line">    type: mime</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> file = dataURLtoFile(imgUrl, <span class="string">"img"</span>);</span><br></pre></td></tr></table></figure><h2 id="file转base64"><a href="#file转base64" class="headerlink" title="file转base64"></a>file转base64</h2><p>base64转blob,blob转file<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoBlob</span> (<span class="params">dataurl</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> arr = dataurl.split(<span class="string">','</span>),</span><br><span class="line">      mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>],</span><br><span class="line">      bstr = atob(arr[<span class="number">1</span>]),</span><br><span class="line">      n = bstr.length,</span><br><span class="line">      u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">      u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123; <span class="attr">type</span>: mime &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//将blob转换为file</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blobToFile</span>:(<span class="params">theBlob, fileName</span>)</span>&#123;</span><br><span class="line">  theBlob.lastModifiedDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  theBlob.name = fileName;</span><br><span class="line">  <span class="keyword">return</span> theBlob;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> blob = dataURLtoBlob(base64Data);</span><br><span class="line"><span class="keyword">var</span> file = blobToFile(blob, imgName);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;base64转file&quot;&gt;&lt;a href=&quot;#base64转file&quot; class=&quot;headerlink&quot; title=&quot;base64转file&quot;&gt;&lt;/a&gt;base64转file&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>export 和 module export</title>
    <link href="http://huangXin1538.github.io/2019/03/15/20190315-6/"/>
    <id>http://huangXin1538.github.io/2019/03/15/20190315-6/</id>
    <published>2019-03-15T07:50:18.000Z</published>
    <updated>2019-03-15T07:50:38.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>async await</title>
    <link href="http://huangXin1538.github.io/2019/03/15/20190315-5/"/>
    <id>http://huangXin1538.github.io/2019/03/15/20190315-5/</id>
    <published>2019-03-15T07:32:56.000Z</published>
    <updated>2019-03-15T07:33:17.336Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="js es6" scheme="http://huangXin1538.github.io/tags/js-es6/"/>
    
  </entry>
  
  <entry>
    <title>js作用域详解</title>
    <link href="http://huangXin1538.github.io/2019/03/15/20190315-4/"/>
    <id>http://huangXin1538.github.io/2019/03/15/20190315-4/</id>
    <published>2019-03-15T01:45:23.000Z</published>
    <updated>2019-04-02T08:05:50.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>js中全局作用域比较简单，在代码任何地方都有定义。<br>函数的参数和局部变量只在函数内有定义。<br>局部变量优先级高于同名全局变量，当局部变量和全局变量同名，局部变量覆盖全局变量</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>在变量声明的代码段之外没有定义，成为块级作用域。<br>js中使用的是函数作用域（变量在声明他们的函数体以及这个函数体嵌套的任何函数体都是有定义的）</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>js中函数也是对象，一切都是对象。函数拥有可以通过代码访问的属性和一系列仅供js引擎访问的内部属性。<br>其中一个内部属性是[[scope]]。该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问<br>函数被创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。</p><p>执行函数时，会创建一个称为‘运行期上下文’的内部对象，运行期上下文定义了函数执行的环境。每个运行期上下文都有自己的作用域链，用于标识符解析。<br>当运行期上下文被创建时，它的作用域链接初始化为当前运行函数的[[scope]]所包含的对象。</p><p>这些值，按照出现在函数中的顺序被复制到运行期上下文的作用域中。它们共同组成一个新的对象，叫做‘活动对象’。该对象包含了函数的所有的局部变量，命名参数、参数集合以及this，然后此对象被推入作用域链的前端，当运行期上下文被销毁时，活动对象也随之销毁</p><h2 id="函数解析和执行过程"><a href="#函数解析和执行过程" class="headerlink" title="函数解析和执行过程"></a>函数解析和执行过程</h2><p>a();</p><p>解析：<br>1.代码进入浏览器，因为会有标识符解析，所以在这之前，js解释器需要扫面全局，初始化全局作用域。<br>2.a变量进入全局作用域，a仍是undefined，当解释器自上而下解释到这段代码时,创建一个匿名函数<br>3.将全局作用域压进函数对象的内部属性 所引用的作用域链里[[scope]]<br>4.将匿名对象赋值给a</p><p>执行<br>1.创建内部对象，称为该对象的‘执行期上下文’。定义了一个函数的执行环境，函数每次执行都会创建独一无二的执行期上下文，每个执行期上下文都有自己的作用域链，用来解析标识符。<br>2.当执行期上下文创建时，它的作用域链会被初始化为当前执行的函数对象里的[[scope]]属性中包含的对象<br>3.scope中的值，按照它们原有的顺序被复制到执行期上下文的作用链里<br>4.解析器创建一个称为‘活动对象’的内部对象，活动对象包含当前执行函数里所有的局部变量，命名参数，参数合计以及this。<br>5.活动对象被推入执行期上下文里中作用域链的前端。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量作用域&quot;&gt;&lt;a href=&quot;#变量作用域&quot; class=&quot;headerlink&quot; title=&quot;变量作用域&quot;&gt;&lt;/a&gt;变量作用域&lt;/h2&gt;&lt;p&gt;js中全局作用域比较简单，在代码任何地方都有定义。&lt;br&gt;函数的参数和局部变量只在函数内有定义。&lt;br&gt;局部变量优先
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>css 三栏布局以及延伸</title>
    <link href="http://huangXin1538.github.io/2019/03/15/20190315-3/"/>
    <id>http://huangXin1538.github.io/2019/03/15/20190315-3/</id>
    <published>2019-03-15T01:44:33.000Z</published>
    <updated>2019-03-15T01:44:58.935Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="css" scheme="http://huangXin1538.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css 边距重叠 与 BFC</title>
    <link href="http://huangXin1538.github.io/2019/03/15/20190315-2/"/>
    <id>http://huangXin1538.github.io/2019/03/15/20190315-2/</id>
    <published>2019-03-15T01:43:47.000Z</published>
    <updated>2019-03-15T01:44:16.580Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="css" scheme="http://huangXin1538.github.io/tags/css/"/>
    
  </entry>
  
</feed>
