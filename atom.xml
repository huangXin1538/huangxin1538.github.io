<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>希染</title>
  
  <subtitle>愿你走过半生，归来仍是少年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangXin1538.github.io/"/>
  <updated>2019-03-04T01:55:42.493Z</updated>
  <id>http://huangXin1538.github.io/</id>
  
  <author>
    <name>希染</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>object方法</title>
    <link href="http://huangXin1538.github.io/2019/02/28/20190228-1/"/>
    <id>http://huangXin1538.github.io/2019/02/28/20190228-1/</id>
    <published>2019-02-28T04:00:07.000Z</published>
    <updated>2019-03-04T01:55:42.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Object-assign-target-source1-source2-…-合并对象"><a href="#1-Object-assign-target-source1-source2-…-合并对象" class="headerlink" title="1. Object.assign(target,source1,source2,…); 合并对象"></a>1. Object.assign(target,source1,source2,…); 合并对象</h2><p>将源对象的所有可枚举的属性合并到目标对象上。只拷贝源对象的自身属性，不拷贝继承的属性。</p><p>浅拷贝。如果拷贝的某个属性是对象，那么拷贝到的是这个对象的引用。</p><p>只进行值的复制，如果复制的值是个取值函数，那么求值后复制。</p><p>可以处理数组，但会把数组看做对象</p><p>同值属性被覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  x:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  x:<span class="number">1</span>,</span><br><span class="line">  y:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,source);</span><br><span class="line"><span class="comment">//target &#123;x:1,y:0&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-Object-create-prototype-propertiesObject-使用指定的原型对象及其属性去创建一个新的对象"><a href="#2-Object-create-prototype-propertiesObject-使用指定的原型对象及其属性去创建一个新的对象" class="headerlink" title="2.Object.create(prototype,[propertiesObject]); 使用指定的原型对象及其属性去创建一个新的对象"></a>2.Object.create(prototype,[propertiesObject]); 使用指定的原型对象及其属性去创建一个新的对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">  x:<span class="number">0</span>,</span><br><span class="line">  y:<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a,&#123;</span><br><span class="line">  z:&#123;</span><br><span class="line">    writable:<span class="literal">true</span>, <span class="comment">//是否可以采用 数据运算符 进行赋值</span></span><br><span class="line">    configurable:<span class="literal">true</span>,  <span class="comment">//是否可以修改、删除</span></span><br><span class="line">    value: <span class="string">"newAdd"</span> <span class="comment">//值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">输出： b = &#123;<span class="attr">z</span>:<span class="string">'newAdd'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Object-defineProperties-obj-props-直接在一个对象上定义新的属性或修改现有属性，并返回该对象-（批量）"><a href="#3-Object-defineProperties-obj-props-直接在一个对象上定义新的属性或修改现有属性，并返回该对象-（批量）" class="headerlink" title="3.Object.defineProperties(obj,props); 直接在一个对象上定义新的属性或修改现有属性，并返回该对象 （批量）"></a>3.Object.defineProperties(obj,props); 直接在一个对象上定义新的属性或修改现有属性，并返回该对象 （批量）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="string">'property1'</span>: &#123;    </span><br><span class="line">       value: <span class="literal">true</span>,  </span><br><span class="line">        writable: <span class="literal">true</span> </span><br><span class="line">   &#125;,  </span><br><span class="line">  <span class="string">'property2'</span>: &#123;   </span><br><span class="line">     value: <span class="string">'Hello'</span>,</span><br><span class="line">     writable: <span class="literal">false</span>  </span><br><span class="line">  &#125;  <span class="comment">// etc. etc.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;property1: true, property2: "Hello"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4-Object-defineProperty-obj-prop-descriptor-在一个对象上定义一个新属性，或者修改一个对象的现有属性，-并返回这个对象。（单个）"><a href="#4-Object-defineProperty-obj-prop-descriptor-在一个对象上定义一个新属性，或者修改一个对象的现有属性，-并返回这个对象。（单个）" class="headerlink" title="4.Object.defineProperty(obj,prop,descriptor); 在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。（单个）"></a>4.Object.defineProperty(obj,prop,descriptor); 在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。（单个）</h2><p>obj：必需。目标对象<br>prop：必需。需定义或修改的属性的名字<br>descriptor：必需。目标属性所拥有的特性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Object</span> = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'is'</span>, </span><br><span class="line">&#123;  </span><br><span class="line">     value: <span class="number">2</span>,  </span><br><span class="line">     configurable: <span class="literal">true</span>,  <span class="comment">// 是否可以删除或者再次修改属性</span></span><br><span class="line">     enumerable: <span class="literal">false</span>,  <span class="comment">//是否可以被枚举</span></span><br><span class="line">     writable: <span class="literal">true</span>   <span class="comment">//  是否可以被重写</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// Object = &#123;is:2&#125;</span></span><br><span class="line"><span class="comment">// 注意不能同时设置(writable，value) 和 get，set方法，否则浏览器会报错  </span></span><br><span class="line"><span class="comment">// 如果不设置属性特性。configurable、enumerable、writable 都默认为false</span></span><br><span class="line"><span class="comment">//Invalid property descriptor.  Cannot both specify accessors and a value or writable attribute</span></span><br></pre></td></tr></table></figure></p><p>getter/setter<br>当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。</p><p>getter 是一种获得属性值的方法<br>setter是一种设置属性值的方法。</p><p>可在获取值和设置值的时候触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> initValue = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"newKey"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function ()&#123;</span><br><span class="line">        <span class="comment">//当获取值的时候触发的函数</span></span><br><span class="line">        <span class="keyword">return</span> initValue;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function (value)&#123;</span><br><span class="line">        <span class="comment">//当设置值的时候触发的函数,设置的新值通过参数value拿到</span></span><br><span class="line">        initValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">obj.newKey = <span class="string">'change value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//change value</span></span><br></pre></td></tr></table></figure><h2 id="5-Object-keys-返回一个由一个给定对象的自身可枚举属性组成的数组-顺序与for…in获取的相同，但是for-i还会魅族其原型链的属性"><a href="#5-Object-keys-返回一个由一个给定对象的自身可枚举属性组成的数组-顺序与for…in获取的相同，但是for-i还会魅族其原型链的属性" class="headerlink" title="5.Object.keys(); 返回一个由一个给定对象的自身可枚举属性组成的数组,顺序与for…in获取的相同，但是for..i还会魅族其原型链的属性"></a>5.Object.keys(); 返回一个由一个给定对象的自身可枚举属性组成的数组,顺序与for…in获取的相同，但是for..i还会魅族其原型链的属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr));<span class="comment">// ['0', '1', '2']/* Object 对象 */</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="string">"bar"</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;, keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="built_in">console</span>.log(keys);<span class="comment">// ["foo","baz"]</span></span><br></pre></td></tr></table></figure><h2 id="6-Object-values-方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同-区别在于-for-in-循环枚举原型链中的属性-。Object-values会过滤属性名为-Symbol-值的属性。"><a href="#6-Object-values-方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同-区别在于-for-in-循环枚举原型链中的属性-。Object-values会过滤属性名为-Symbol-值的属性。" class="headerlink" title="6.Object.values(); 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。Object.values会过滤属性名为 Symbol 值的属性。"></a>6.Object.values(); 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。Object.values会过滤属性名为 Symbol 值的属性。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> an_obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(an_obj)); <span class="comment">// ['b', 'c', 'a']</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><h2 id="7-Object-entries-返回一个给定对象自身可枚举属性的键值对数组，其排列与使用-for…in-循环遍历该对象时返回的顺序一致（区别在于-for-in-循环也枚举原型链中的属性）。"><a href="#7-Object-entries-返回一个给定对象自身可枚举属性的键值对数组，其排列与使用-for…in-循环遍历该对象时返回的顺序一致（区别在于-for-in-循环也枚举原型链中的属性）。" class="headerlink" title="7.Object.entries(); 返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。"></a>7.Object.entries(); 返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ ['foo', 'bar'], ['baz', 42] ]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> simuArray = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(simuArray)); <span class="comment">// [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]</span></span><br></pre></td></tr></table></figure><h2 id="8-hasOwnProperty"><a href="#8-hasOwnProperty" class="headerlink" title="8.hasOwnProperty()"></a>8.hasOwnProperty()</h2><p>判断对象自身属性中是否具有指定的属性。</p><p>obj.hasOwnProperty(‘name’)</p><h2 id="9-Object-getOwnPropertyDescriptor-obj-prop-返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）-如果指定的属性存在于对象上，则返回其属性描述符对象（property-descriptor），否则返回-undefined。"><a href="#9-Object-getOwnPropertyDescriptor-obj-prop-返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）-如果指定的属性存在于对象上，则返回其属性描述符对象（property-descriptor），否则返回-undefined。" class="headerlink" title="9.Object.getOwnPropertyDescriptor(obj,prop);返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）.如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。"></a>9.Object.getOwnPropertyDescriptor(obj,prop);返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）.如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'name'</span>,<span class="string">'age'</span>] ;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,val)))</span><br><span class="line"><span class="comment">// &#123;value: "js", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="10-Object-getOwnPropertyDescriptors-obj-获取一个对象的所有自身属性的描述符。"><a href="#10-Object-getOwnPropertyDescriptors-obj-获取一个对象的所有自身属性的描述符。" class="headerlink" title="10.  Object.getOwnPropertyDescriptors(obj)  获取一个对象的所有自身属性的描述符。"></a>10.  Object.getOwnPropertyDescriptors(obj)  获取一个对象的所有自身属性的描述符。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'js'</span>,</span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj))</span><br></pre></td></tr></table></figure><h2 id="11-Object-getOwnPropertyNames-返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。"><a href="#11-Object-getOwnPropertyNames-返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。" class="headerlink" title="11. Object.getOwnPropertyNames(); 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。"></a>11. Object.getOwnPropertyNames(); 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>, <span class="number">2</span>: <span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'z'</span>,&#123;</span><br><span class="line">    enumerable : <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj))  <span class="comment">// ["x", "y", "z"] 包含不可枚举属性 。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))                 <span class="comment">// ["x", "y"]      只包含可枚举属性 。</span></span><br></pre></td></tr></table></figure><h2 id="12-Object-getOwnPropertySymbols-返回一个给定对象自身的所有-Symbol-属性的数组。"><a href="#12-Object-getOwnPropertySymbols-返回一个给定对象自身的所有-Symbol-属性的数组。" class="headerlink" title="12 Object.getOwnPropertySymbols();返回一个给定对象自身的所有 Symbol 属性的数组。"></a>12 Object.getOwnPropertySymbols();返回一个给定对象自身的所有 Symbol 属性的数组。</h2><h2 id="13-isPrototypeOf-判断一个对象是否存在一另一个对象的原型链上"><a href="#13-isPrototypeOf-判断一个对象是否存在一另一个对象的原型链上" class="headerlink" title="13 isPrototypeOf(); 判断一个对象是否存在一另一个对象的原型链上"></a>13 isPrototypeOf(); 判断一个对象是否存在一另一个对象的原型链上</h2><h2 id="14-Object-getOwnPropertySymbols-返回一个给定对象自身的所有-Symbol-属性的数组。"><a href="#14-Object-getOwnPropertySymbols-返回一个给定对象自身的所有-Symbol-属性的数组。" class="headerlink" title="14 Object.getOwnPropertySymbols(); 返回一个给定对象自身的所有 Symbol 属性的数组。"></a>14 Object.getOwnPropertySymbols(); 返回一个给定对象自身的所有 Symbol 属性的数组。</h2><h2 id="15-Object-is-判断两个对象是否相同"><a href="#15-Object-is-判断两个对象是否相同" class="headerlink" title="15 Object.is(); 判断两个对象是否相同"></a>15 Object.is(); 判断两个对象是否相同</h2><p>如果下列任何一项成立，则返回true<br>两个值都是 undefined<br>两个值都是 null<br>两个值都是 true 或者都是 false<br>两个值是由相同个数的字符按照相同的顺序组成的字符串<br>两个值指向同一个对象<br>两个值都是数字并且<br>都是正零 +0<br>都是负零 -0<br>都是 NaN<br>都是除零和 NaN 外的其它同一个数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="built_in">window</span>, <span class="built_in">window</span>);   <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'bar'</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is([], []);           <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> test = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.is(test, test);       <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>);       <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 特例</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span>/<span class="number">0</span>);         <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="16-Object-freeze-冻结一个对象。被冻结的对象-是永远不变的，返回被冻结的对象"><a href="#16-Object-freeze-冻结一个对象。被冻结的对象-是永远不变的，返回被冻结的对象" class="headerlink" title="16 Object.freeze() 冻结一个对象。被冻结的对象 是永远不变的，返回被冻结的对象"></a>16 Object.freeze() 冻结一个对象。被冻结的对象 是永远不变的，返回被冻结的对象</h2><h2 id="17-Object-isFrozen-判断一个对象是否被冻结"><a href="#17-Object-isFrozen-判断一个对象是否被冻结" class="headerlink" title="17 Object.isFrozen() 判断一个对象是否被冻结 ."></a>17 Object.isFrozen() 判断一个对象是否被冻结 .</h2><h2 id="18-Object-preventExtensions-对象不能再添加新的属性。可修改，删除现有属性"><a href="#18-Object-preventExtensions-对象不能再添加新的属性。可修改，删除现有属性" class="headerlink" title="18 Object.preventExtensions()  对象不能再添加新的属性。可修改，删除现有属性"></a>18 Object.preventExtensions()  对象不能再添加新的属性。可修改，删除现有属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name :<span class="string">'lilei'</span>,</span><br><span class="line">    age : <span class="number">30</span> ,</span><br><span class="line">    sex : <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">obj = <span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj);    <span class="comment">// &#123;name: "lilei", age: 30, sex: "male"&#125;</span></span><br><span class="line">obj.name = <span class="string">'haha'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj)     <span class="comment">// &#123;name: "haha", age: 30, sex: "male"&#125;</span></span><br><span class="line"><span class="keyword">delete</span> obj.sex ;</span><br><span class="line"><span class="built_in">console</span>.log(obj);    <span class="comment">// &#123;name: "haha", age: 30&#125;</span></span><br><span class="line">obj.address  = <span class="string">'china'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj)     <span class="comment">// &#123;name: "haha", age: 30&#125;</span></span><br></pre></td></tr></table></figure><h2 id="19-Object-isExtensible-判断对象是否是可扩展的，Object-preventExtensions，Object-seal-或-Object-freeze-方法都可以标记一个对象为不可扩展（non-extensible）"><a href="#19-Object-isExtensible-判断对象是否是可扩展的，Object-preventExtensions，Object-seal-或-Object-freeze-方法都可以标记一个对象为不可扩展（non-extensible）" class="headerlink" title="19 Object.isExtensible() 判断对象是否是可扩展的，Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）"></a>19 Object.isExtensible() 判断对象是否是可扩展的，Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）</h2><h2 id="20-Object-seal-让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError-异常-不会影响从原型链上继承的属性。但-proto-属性的值也会不能修改。"><a href="#20-Object-seal-让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError-异常-不会影响从原型链上继承的属性。但-proto-属性的值也会不能修改。" class="headerlink" title="20 Object.seal() 让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常. 不会影响从原型链上继承的属性。但 proto (  ) 属性的值也会不能修改。"></a>20 Object.seal() 让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常. 不会影响从原型链上继承的属性。但 <strong>proto</strong> (  ) 属性的值也会不能修改。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prop: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    foo: <span class="string">"bar"</span></span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可以添加新的属性,已有属性的值可以修改,可以删除</span></span><br><span class="line">obj.foo = <span class="string">"baz"</span>;</span><br><span class="line">obj.lumpy = <span class="string">"woof"</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.prop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(obj);</span><br><span class="line"> </span><br><span class="line">assert(o === obj);</span><br><span class="line">assert(<span class="built_in">Object</span>.isSealed(obj) === <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 仍然可以修改密封对象上的属性的值.</span></span><br><span class="line">obj.foo = <span class="string">"quux"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 但你不能把一个数据属性重定义成访问器属性.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"foo"</span>, &#123; <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"g"</span>; &#125; &#125;); <span class="comment">// 抛出TypeError异常</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 现在,任何属性值以外的修改操作都会失败.</span></span><br><span class="line">obj.quaxxor = <span class="string">"the friendly duck"</span>; <span class="comment">// 静默失败,新属性没有成功添加</span></span><br><span class="line"><span class="keyword">delete</span> obj.foo; <span class="comment">// 静默失败,属性没有删除成功</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...在严格模式中,会抛出TypeError异常</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">delete</span> obj.foo; <span class="comment">// 抛出TypeError异常</span></span><br><span class="line">  obj.sparky = <span class="string">"arf"</span>; <span class="comment">// 抛出TypeError异常</span></span><br><span class="line">&#125;</span><br><span class="line">fail();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用Object.defineProperty方法同样会抛出异常</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"ohai"</span>, &#123; <span class="attr">value</span>: <span class="number">17</span> &#125;); <span class="comment">// 抛出TypeError异常</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"foo"</span>, &#123; <span class="attr">value</span>: <span class="string">"eit"</span> &#125;); <span class="comment">// 成功将原有值改变</span></span><br></pre></td></tr></table></figure><h2 id="21-Object-isSealed-判断一个对象是否密闭"><a href="#21-Object-isSealed-判断一个对象是否密闭" class="headerlink" title="21.Object.isSealed() 判断一个对象是否密闭"></a>21.Object.isSealed() 判断一个对象是否密闭</h2><h2 id="Object状态"><a href="#Object状态" class="headerlink" title="Object状态:"></a>Object状态:</h2><p>1.冻结。永远不会变<br>2.密闭。<br>  a:不可添加新属性<br>  b:已有属性变的不可删除<br>  c:数据的属性不能被重新定义为转换器属性<br>  d:属性值仍然可以修改<br>  e:尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常. 不会影响从原型链上继承的属性<br>  f:<strong>proto</strong> (  ) 属性的值也会不能修改<br>3.不可扩展：对象不能再添加新的属性。可修改，删除现有属性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Object-assign-target-source1-source2-…-合并对象&quot;&gt;&lt;a href=&quot;#1-Object-assign-target-source1-source2-…-合并对象&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>call 和 apply 用法</title>
    <link href="http://huangXin1538.github.io/2019/02/26/20190226-1/"/>
    <id>http://huangXin1538.github.io/2019/02/26/20190226-1/</id>
    <published>2019-02-26T02:47:42.000Z</published>
    <updated>2019-03-04T01:55:36.366Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue首屏加载时间过长优化</title>
    <link href="http://huangXin1538.github.io/2019/02/21/20190221-1/"/>
    <id>http://huangXin1538.github.io/2019/02/21/20190221-1/</id>
    <published>2019-02-21T06:53:13.000Z</published>
    <updated>2019-03-04T01:55:32.893Z</updated>
    
    <content type="html"><![CDATA[<p>主要思路：减小首屏加载的js文件体积</p><h2 id="1-减少不必要的引用"><a href="#1-减少不必要的引用" class="headerlink" title="1.减少不必要的引用"></a>1.减少不必要的引用</h2><p>1.看package.json;<br>2.查看打包分析<br>  安装 webpack-bundle-analyzer<br>  vue.config.js配置<br>  chainWebpack: (config) =&gt; {  //打包分析<br>    config.plugin(‘webpack-bundle-analyzer’)<br>      .use(BundleAnalyzerPlugin)<br>        .init(Plugin =&gt; new Plugin());<br>  },<br>  run build –report</p><h2 id="2-路由懒加载，组件懒加载"><a href="#2-路由懒加载，组件懒加载" class="headerlink" title="2.路由懒加载，组件懒加载"></a>2.路由懒加载，组件懒加载</h2><h2 id="3-引用转为cdn"><a href="#3-引用转为cdn" class="headerlink" title="3.引用转为cdn"></a>3.引用转为cdn</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要思路：减小首屏加载的js文件体积&lt;/p&gt;
&lt;h2 id=&quot;1-减少不必要的引用&quot;&gt;&lt;a href=&quot;#1-减少不必要的引用&quot; class=&quot;headerlink&quot; title=&quot;1.减少不必要的引用&quot;&gt;&lt;/a&gt;1.减少不必要的引用&lt;/h2&gt;&lt;p&gt;1.看package.j
      
    
    </summary>
    
    
      <category term="vue" scheme="http://huangXin1538.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>flex兼容</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-12/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-12/</id>
    <published>2019-01-30T09:49:51.000Z</published>
    <updated>2019-03-04T01:55:29.444Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>旧版本dispaly: box;，过渡版本dispaly: flex box;，以及现在的标准版本display: flex</p><p>Android<br>2.3 开始就支持旧版本 display:-webkit-box;<br>4.4 开始支持标准版本 display: flex;</p><p>IOS<br>6.1 开始支持旧版本 display:-webkit-box;<br>7.1 开始支持标准版本display: flex;</p><p>PC<br>ie10开始支持，但是IE10的是-ms形式的。</p><p>###</p><p>###<br>写法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box; <span class="comment">/* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */</span></span><br><span class="line">  <span class="attribute">display</span>: -moz-box; <span class="comment">/* 老版本语法: Firefox (buggy) */</span></span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox; <span class="comment">/* 混合版本语法: IE 10 */</span></span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* 新版本语法: Chrome 21+ */</span></span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* 新版本语法: Opera 12.1, Firefox 22+ */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-1</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-flex</span>: <span class="number">1</span>; <span class="comment">/* Chrome */</span></span><br><span class="line">  <span class="attribute">-ms-flex</span>: <span class="number">1</span>; <span class="comment">/* IE 10 */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* NEW, Spec - Opera 12.1, Firefox 20+ */</span></span><br><span class="line">  <span class="attribute">-webkit-box-flex</span>: <span class="number">1</span>; <span class="comment">/* OLD - iOS 6-, Safari 3.1-6 */</span></span><br><span class="line">  <span class="attribute">-moz-box-flex</span>: <span class="number">1</span>; <span class="comment">/* OLD - Firefox 19- */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-v</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">  <span class="attribute">-webkit-flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">-ms-flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-align-center</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-align-items</span>: center;</span><br><span class="line">  <span class="attribute">-ms-flex-align</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-pack-center</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-justify-content</span>: center;</span><br><span class="line">  <span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-pack-justify</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-pack</span>: justify;</span><br><span class="line">  <span class="attribute">-webkit-justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">-ms-flex-pack</span>: justify;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-pack-around</span> &#123;</span><br><span class="line">　　<span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">　　<span class="attribute">-webkit-justify-content</span>: space-around;</span><br><span class="line">　　<span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">　　<span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>兼容性：ios 4+、android 2.3+、winphone8+</p><p>###</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;br&gt;旧版本dispaly: box;，过渡版本dispaly: flex box;，以及现在的标准版本display: flex&lt;/p&gt;
&lt;p&gt;Android&lt;br&gt;2.3 开始就支持旧版本 display:-webkit-box;&lt;br&gt;4.4 开始支持标准版本
      
    
    </summary>
    
    
      <category term="css" scheme="http://huangXin1538.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js实现面向对象</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-11/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-11/</id>
    <published>2019-01-30T09:49:48.000Z</published>
    <updated>2019-03-04T01:55:24.777Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>面向对象：将抽象模型实例化为对象，属性和方法都通过操作对象来获取和实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">color,name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color:color,</span><br><span class="line">  <span class="keyword">this</span>.name:name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'黄色'</span>,<span class="string">'大毛'</span>);</span><br></pre></td></tr></table></figure></p><p>###</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;br&gt;面向对象：将抽象模型实例化为对象，属性和方法都通过操作对象来获取和实现。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>css单位</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-10/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-10/</id>
    <published>2019-01-30T09:49:44.000Z</published>
    <updated>2019-03-04T01:55:21.311Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>%:百分比<br>cm：厘米<br>mm：毫米<br>px:像素<br>in：英寸</p><p>rgb(x,x,x)    RGB 值 (比如 rgb(255,0,0))<br>rgb(x%, x%, x%)    RGB 百分比值 (比如 rgb(100%,0%,0%))</p><p>#rrggbb    十六进制数 (比如 #ff0000)</p><p>新属性<br>vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）<br>vh：视窗高度的百分比<br>vmin：当前 vw 和 vh 中较小的一个值<br>vmax：当前 vw 和 vh 中较大的一个值</p><p>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。<br>由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</p><p>Android：自 4.4 版起就完美支持（2013年12月）<br>iOS：自 iOS8 版起就完美支持（2014年9月）</p><p>###</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;br&gt;%:百分比&lt;br&gt;cm：厘米&lt;br&gt;mm：毫米&lt;br&gt;px:像素&lt;br&gt;in：英寸&lt;/p&gt;
&lt;p&gt;rgb(x,x,x)    RGB 值 (比如 rgb(255,0,0))&lt;br&gt;rgb(x%, x%, x%)    RGB 百分比值 (比如 rgb(100%
      
    
    </summary>
    
    
      <category term="css" scheme="http://huangXin1538.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css 动画</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-9/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-9/</id>
    <published>2019-01-30T09:49:40.000Z</published>
    <updated>2019-03-04T01:55:15.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><p>指控制最开始的状态和最末的状态的动画，中间的状态由浏览器自动帮我们计算生成。</p><h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><p>时间轴上定义关键帧，通过连续播放形成动画</p><h3 id="实现属性"><a href="#实现属性" class="headerlink" title="实现属性"></a>实现属性</h3><p>css animation<br>css transiton</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;补间动画&quot;&gt;&lt;a href=&quot;#补间动画&quot; class=&quot;headerlink&quot; title=&quot;补间动画&quot;&gt;&lt;/a&gt;补间动画&lt;/h3&gt;&lt;p&gt;指控制最开始的状态和最末的状态的动画，中间的状态由浏览器自动帮我们计算生成。&lt;/p&gt;
&lt;h3 id=&quot;逐帧动画&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="css" scheme="http://huangXin1538.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>promise</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-8/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-8/</id>
    <published>2019-01-30T09:49:36.000Z</published>
    <updated>2019-03-13T09:30:38.383Z</updated>
    
    <content type="html"><![CDATA[<p>###</p><p>js 实现异步操作的一种方式</p><p>三种状态 等待（pending）、已完成（fulfilled）、已拒绝（rejected）</p><p>Promise 的构造函数接收一个函数作为参数，该函数接受两个额外的函数，resolve 和 reject，这两个函数分别代表将当前 Promise 置为 fulfilled(解决)和 rejected(拒绝)两个状态。Promise 正是通过这两个状态来控制异步操作的结果</p><p>resolve()内部的参数会传递给 then(); reject 方法参数传给 catch();</p><p>当 Promise 中的函数执行 resolve 方法后，由之前的 pending –&gt; resolved</p><p>基础例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (执行某些操作成功了) &#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            name:<span class="string">'resolve'</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//执行失败</span></span><br><span class="line">          reject(&#123;</span><br><span class="line">            name:<span class="string">'err'</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br><span class="line">同时监听成功和错误</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//成功</span></span><br><span class="line">  <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//拒绝</span></span><br><span class="line">  <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line">只监听成功</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//成功</span></span><br><span class="line">  <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">只监听错误</span><br><span class="line">promise.then(<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//拒绝</span></span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise的<span class="keyword">catch</span>方法，相当于只给其传入拒绝处理程序的then()方法。</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="多个函数实战"><a href="#多个函数实战" class="headerlink" title="多个函数实战"></a>多个函数实战</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br><span class="line">  .then(b())</span><br><span class="line">  .then(c());</span><br></pre></td></tr></table></figure><h3 id="Promise-then-回调异步性"><a href="#Promise-then-回调异步性" class="headerlink" title="Promise.then()回调异步性"></a>Promise.then()回调异步性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</span><br><span class="line"></span><br><span class="line">success后执行;</span><br></pre></td></tr></table></figure><h3 id="then"><a href="#then" class="headerlink" title=".then()"></a>.then()</h3><p>语法：Promise.prototype.then(onFulfilled, onRejected);</p><p>对 promise添加onFulfilled 和 onRejected 回调，并返回一个新的Promise实例，且返回值将作为参数传入这个心的Promise的resolve函数</p><p>因此，可以使用链式写法。后一个回调函数，会等待前一个promise对象的状态发生变化，才会被调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (执行某些操作成功了) &#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            name:<span class="string">'resolve'</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//执行失败</span></span><br><span class="line">          reject(&#123;</span><br><span class="line">            name:<span class="string">'err'</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//resolve时执行</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//reject时执行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h3><p>.then(undefinedn,onRejected)的别名，用于指定发生错误时的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******等同于*******/</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;).then(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h3><p>var p = Promise.all([p1,p2,p3]);</p><p>该方法接受一个数组作参数，数组中对象均为promise实例(如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。<br>p 的状态由这三个promise实例决定。</p><p>p1,p2,p3 也是同时执行，不是顺序执行</p><p>当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>, <span class="string">"one"</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">  setTimeout(reject, <span class="number">2000</span>, <span class="string">"two"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>, <span class="string">"third"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolve'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reject'</span>, error);    <span class="comment">// =&gt; reject three</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//约 3s 后</span></span><br><span class="line">[<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>]</span><br></pre></td></tr></table></figure><p>当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>, <span class="string">"one"</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">  setTimeout(reject, <span class="number">2000</span>, <span class="string">"two"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"three"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolve'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reject'</span>, error);    <span class="comment">// =&gt; reject three</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">reject three</span><br></pre></td></tr></table></figure><h3 id="race"><a href="#race" class="headerlink" title=".race()"></a>.race()</h3><p>该方法同样将多个Promise实例，包装成一个新的Promise实例</p><p>var p = Promise.race([p1,p2,p3]); </p><p>p1,p2,p3谁先有返回，p就返回它的返回</p><p>Promise.race 接收一个数组作参数，当P1,P2,P3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就发生改变，并将第一个改变状态的promise的返回值，传给p的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">    setTimeout(reject, <span class="number">500</span>, <span class="string">"one"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">    setTimeout(resolve, <span class="number">100</span>, <span class="string">"two"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolve'</span>, value); </span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//not called</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reject'</span>, error); </span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">resolve two</span><br></pre></td></tr></table></figure><p>当第一个promise对象变为resolve后，并不会取消其他promise对象的执行</p><h3 id="reslove"><a href="#reslove" class="headerlink" title="reslove();"></a>reslove();</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个方法会让这个Promise对象立即进入resolve状态，并将结果success传递给then执行的onfulfilled回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出 Success</span><br></pre></td></tr></table></figure><h3 id="reject"><a href="#reject" class="headerlink" title=".reject()"></a>.reject()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>));</span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>让Promise对象立即进入rejected状态，并将错误对象传递到执行的onRejected回调函数</p><h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><h3 id="1-reject-和catch-的区别"><a href="#1-reject-和catch-的区别" class="headerlink" title="1. reject 和catch 的区别"></a>1. reject 和catch 的区别</h3><p>promise.then(onfulfilled,onrejected)<br>在onFulfilled中发生异常的话，在onrejected中是捕获不到这个异常的</p><p>promise.then(onFulfilled).catch(onRejected)<br>.then中产生的异常可以在.catch中捕获</p><p>一般情况下，使用catch。<br>catch也可以用then表示<br>.catch === .then(null, onRejected)</p><h3 id="2-如果then中抛出了错误，而没有catch，会一直保持rejected状态，直到catch了错误"><a href="#2-如果then中抛出了错误，而没有catch，会一直保持rejected状态，直到catch了错误" class="headerlink" title="2.如果then中抛出了错误，而没有catch，会一直保持rejected状态，直到catch了错误"></a>2.如果then中抛出了错误，而没有catch，会一直保持rejected状态，直到catch了错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Task A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Task B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Catch Error: A or B"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finalTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Final Task"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">promise</span><br><span class="line">    .then(taskA)</span><br><span class="line">    .then(taskB)</span><br><span class="line">    .catch(onRejected)</span><br><span class="line">    .then(finalTask);</span><br><span class="line">    </span><br><span class="line">-------output-------</span><br><span class="line">Catch <span class="built_in">Error</span>: A or B,<span class="attr">ReferenceError</span>: x is not defined</span><br><span class="line">Final Task</span><br></pre></td></tr></table></figure><h3 id="3-每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据"><a href="#3-每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据" class="headerlink" title="3.每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据"></a>3.每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据</h3><h3 id="4-promise的状态变为resolve活reject-，就凝固了，不会再改变"><a href="#4-promise的状态变为resolve活reject-，就凝固了，不会再改变" class="headerlink" title="4.promise的状态变为resolve活reject ，就凝固了，不会再改变"></a>4.promise的状态变为resolve活reject ，就凝固了，不会再改变</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;/p&gt;
&lt;p&gt;js 实现异步操作的一种方式&lt;/p&gt;
&lt;p&gt;三种状态 等待（pending）、已完成（fulfilled）、已拒绝（rejected）&lt;/p&gt;
&lt;p&gt;Promise 的构造函数接收一个函数作为参数，该函数接受两个额外的函数，resolve 和 reje
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端缓存机制</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-7/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-7/</id>
    <published>2019-01-30T09:49:32.000Z</published>
    <updated>2019-01-30T09:52:13.590Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js安全</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-6/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-6/</id>
    <published>2019-01-30T09:49:29.000Z</published>
    <updated>2019-01-30T09:51:59.679Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css BFC</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-5/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-5/</id>
    <published>2019-01-30T09:49:25.000Z</published>
    <updated>2019-01-30T09:51:50.611Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js模块化</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-4/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-4/</id>
    <published>2019-01-30T09:49:22.000Z</published>
    <updated>2019-03-04T01:55:05.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-无模块化"><a href="#1-无模块化" class="headerlink" title="1.无模块化"></a>1.无模块化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"jquery.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"jquery_scroller.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>缺点：1.污染全局作用域  2.依赖关系不明显</p><h2 id="2-commonJS规范"><a href="#2-commonJS规范" class="headerlink" title="2. commonJS规范"></a>2. commonJS规范</h2><p>最初应用于服务端<br>前端webpack也对CommonJS原生支持</p><p>每一个文件就是一个模块，内部定义的变量属于这个模块，不会对外暴露，不会污染全局。</p><p>核心思想：通过require同步加载所要依赖的其他模块，通过exports 或者module.exports 来导出需要暴露的接口</p><p>module代表这个模块，exports代表要暴露的接口，默认顶部有一句代码 exports = module.exports</p><p>所以不能直接给exports赋值， 如 number/function等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>优点：commonJS率先在服务端完成模块化，解决了依赖全局变量污染的问题<br>缺点：由于commonJS是同步加载模块，在浏览器端不适用。</p><h2 id="3-AMD规范"><a href="#3-AMD规范" class="headerlink" title="3. AMD规范"></a>3. AMD规范</h2><p>AMD规范则是非同步加载模块，允许指定回调函数.AMD规范的实现：require.js<br>AMD标准定义了两个API<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">require</span>([<span class="built_in">module</span>],callback)</span><br><span class="line"><span class="number">2.</span>define(id,[depends],callback)</span><br></pre></td></tr></table></figure></p><p>即通过define定义模块，require加载模块。且require支持commonJS的模块导出方式、</p><p>定义alert模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alertName = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"I am "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> alertAge = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"I am "</span> + num + <span class="string">" years old"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      alertName: alertName,</span><br><span class="line">      alertAge: alertAge</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>引入模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'alert'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">alert</span>) </span>&#123;</span><br><span class="line">  alert.alertName(<span class="string">'JohnZhu'</span>);</span><br><span class="line">  alert.alertAge(<span class="number">21</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在使用requireJS时候，必须提前加载所有的依赖，然后才能使用</p><p>优点:适合在浏览器端异步加载模块，可以并行加载多个模块<br>缺点：提高了开发成本，并且不能按需加载，必须提前加载完所有依赖</p><h2 id="4-CMD规范"><a href="#4-CMD规范" class="headerlink" title="4.CMD规范"></a>4.CMD规范</h2><p>CMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">  <span class="keyword">var</span> Spinning = <span class="built_in">require</span>(<span class="string">'./spinning'</span>);</span><br><span class="line">  exports.doSomething = ...</span><br><span class="line">  <span class="built_in">module</span>.exports = ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>优点： 浏览器端模块加载，按需加载，依赖就近<br>缺点： 依赖SPM打包，模块的加载逻辑偏重</p><p>AMD和CMD区别：<br>  前者对依赖提前执行，后者延迟执行。<br>  前者推崇依赖前置，后者推崇依赖就近，即在需要时候某个模块在require</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;  <span class="comment">// 依赖必须一开始就写好  </span></span><br><span class="line">   a.doSomething()    </span><br><span class="line">   <span class="comment">// 此处略去 100 行    </span></span><br><span class="line">   b.doSomething()    </span><br><span class="line">   ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)   </span><br><span class="line">   a.doSomething()   </span><br><span class="line">   <span class="comment">// 此处略去 100 行   </span></span><br><span class="line">   <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) </span><br><span class="line">   <span class="comment">// 依赖可以就近书写   </span></span><br><span class="line">   b.doSomething()</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="5-ES6模块化"><a href="#5-ES6模块化" class="headerlink" title="5.ES6模块化"></a>5.ES6模块化</h2><p>之前的模块化都是社区自己实现的，只是得到大家的认可和广泛使用，而ES6是官方推出的真正规范的模块化方案。<br>使用import引入模块，通过export导出模块。<br>目前ES6在浏览器支持性不高，通过babel将import编译为require</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;mapState, mapMutations, mapActions&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'../assets/js/request'</span></span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">'../utils/js/util.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.getClassify(); </span><br><span class="line">  <span class="keyword">this</span>.RESET_VALUE();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'created'</span> ,<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-无模块化&quot;&gt;&lt;a href=&quot;#1-无模块化&quot; class=&quot;headerlink&quot; title=&quot;1.无模块化&quot;&gt;&lt;/a&gt;1.无模块化&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>闭包机制</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-3/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-3/</id>
    <published>2019-01-30T09:49:17.000Z</published>
    <updated>2019-03-01T03:41:46.326Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue双向绑定原理</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-2/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-2/</id>
    <published>2019-01-30T09:49:13.000Z</published>
    <updated>2019-01-30T09:51:12.194Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="vue" scheme="http://huangXin1538.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>eventLoop机制</title>
    <link href="http://huangXin1538.github.io/2019/01/30/20190130-1/"/>
    <id>http://huangXin1538.github.io/2019/01/30/20190130-1/</id>
    <published>2019-01-30T09:49:04.000Z</published>
    <updated>2019-03-04T07:13:17.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-js为单线程"><a href="#1-js为单线程" class="headerlink" title="1.js为单线程"></a>1.js为单线程</h2><p>假设js有两个线程，一个在某个dom添加内容，另一个在这个dom删除内容，浏览器应该以哪个线程为准？<br>这就意味着，单线程为js核心标准，将一直沿用下去。</p><p>web worker : 号称让js成为一门多线程语言<br>所有新线程受主线程的控制，不能独立执行。实际上属于主线程的子线程。<br>子线程没有执行I/O操作的权限，只能为主线程分担计算等任务，严格说，这些线程没有完整功能，并非改变了js的单线程本质。</p><h2 id="2-事件循环"><a href="#2-事件循环" class="headerlink" title="2.事件循环"></a>2.事件循环</h2><p>一直在查找新的事件执行，一次执行的循环成为tick，循环里执行的代码称为task</p><p>任务分同步和异步<br>js执行时将不同变量存在内存的不同位置：堆（heap）和栈（stack）中区分。<br>堆中一般存变量，stack一般存函数和方法。<br>stack叫做执行栈，方法会依次在这里执行。<br>执行栈事件先进先出，任务队列先进先出。<br>web apis代表异步事件，callback queue事件队列</p><p>执行栈执行主线程任务，当有<font color="#ff0000">操作dom，ajax交互，定时器</font> 等异步操作时候，任务会移入到callback queue任务队列<br>当主线程执行完毕后，读取callbakc quene队列中的函数，进入主线程执行。<br>不断重复，就是常说的<font color="#ff0000">事件循环（eventloop）</font></p><h2 id="3-macro-task和-micro-task"><a href="#3-macro-task和-micro-task" class="headerlink" title="3.macro task和 micro task"></a>3.macro task和 micro task</h2><p>不同的异步任务会分为两类：微任务（micro）和宏任务（macro）</p><p>在一个事件循环中，异步事件返回结果后被放到对应的宏任务队列或者微任务队列中去。</p><font color="#ff0000">宏任务-&gt;这个宏任务中的微任务-&gt;下一个宏任务-&gt;下一个宏任务添加的微任务</font><p>当执行栈为空时，主线程会首先查看微任务中的事件，如果微任务不是空执行微任务。如果没有任务，在宏任务中取出最前面的一个事件，把对应的回调加入当前执行栈………  如此反复，进入循环</p><p>macro-task(宏任务)<br>  整体代码<br>  settimeout<br>  setinterval<br>  setlmmediate</p><p>  主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval</p><p>micro-task(微任务)</p><p>  process.nextTick &gt; Promise &gt; MutationObserver</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-js为单线程&quot;&gt;&lt;a href=&quot;#1-js为单线程&quot; class=&quot;headerlink&quot; title=&quot;1.js为单线程&quot;&gt;&lt;/a&gt;1.js为单线程&lt;/h2&gt;&lt;p&gt;假设js有两个线程，一个在某个dom添加内容，另一个在这个dom删除内容，浏览器应该以哪个线
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>meta 标签内属性详解</title>
    <link href="http://huangXin1538.github.io/2018/12/06/20181206-1/"/>
    <id>http://huangXin1538.github.io/2018/12/06/20181206-1/</id>
    <published>2018-12-06T03:50:39.000Z</published>
    <updated>2019-03-04T07:22:16.555Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"参数"</span> content=<span class="string">"具体的描述"</span>&gt;</span><br></pre></td></tr></table></figure><p>meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。</p><h1 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h1><h2 id="A-keywords"><a href="#A-keywords" class="headerlink" title="A.keywords"></a>A.keywords</h2><p>用于告诉搜索引擎，你网页的关键字。举例：</p><meta name="keywords" content="博客，前端"><h2 id="B-description"><a href="#B-description" class="headerlink" title="B.description"></a>B.description</h2><p>用于告诉搜索引擎，你网站的主要内容。举例：</p><meta name="description" content="这是我的前端博客"><h2 id="C-viewport-移动端的窗口"><a href="#C-viewport-移动端的窗口" class="headerlink" title="C. viewport(移动端的窗口)"></a>C. viewport(移动端的窗口)</h2><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><h3 id="width-device-width"><a href="#width-device-width" class="headerlink" title="width = device-width"></a>width = device-width</h3><p>宽度等于当前设备的宽度</p><h3 id="initial-scale-1-0"><a href="#initial-scale-1-0" class="headerlink" title="initial-scale = 1.0"></a>initial-scale = 1.0</h3><p>初始缩放比例，默认为1（倍）</p><h3 id="minimum-scale-1-0-maximum-scale-1-0"><a href="#minimum-scale-1-0-maximum-scale-1-0" class="headerlink" title="minimum-scale = 1.0/maximum-scale = 1.0"></a>minimum-scale = 1.0/maximum-scale = 1.0</h3><p>最小/大缩放比例1（倍）</p><h3 id="user-scalable-no"><a href="#user-scalable-no" class="headerlink" title="user-scalable = no"></a>user-scalable = no</h3><p>是否允许用户缩放页面（yes/no）</p><h2 id="D-robot"><a href="#D-robot" class="headerlink" title="D.robot"></a>D.robot</h2><p>robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。content的参数有all,none,index,noindex,follow,nofollow。默认是all。<br>举例：<meta name="robots" content="none"></p><h3 id="1-none-搜索引擎将忽略此网页，等价于noindex，nofollow。"><a href="#1-none-搜索引擎将忽略此网页，等价于noindex，nofollow。" class="headerlink" title="1.none : 搜索引擎将忽略此网页，等价于noindex，nofollow。"></a>1.none : 搜索引擎将忽略此网页，等价于noindex，nofollow。</h3><h3 id="2-noindex-搜索引擎不索引此网页。"><a href="#2-noindex-搜索引擎不索引此网页。" class="headerlink" title="2.noindex : 搜索引擎不索引此网页。"></a>2.noindex : 搜索引擎不索引此网页。</h3><h3 id="3-nofollow-搜索引擎不继续通过此网页的链接索引搜索其它的网页。"><a href="#3-nofollow-搜索引擎不继续通过此网页的链接索引搜索其它的网页。" class="headerlink" title="3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。"></a>3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。</h3><h3 id="4-all-搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。"><a href="#4-all-搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。" class="headerlink" title="4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。"></a>4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。</h3><h3 id="5-index-搜索引擎索引此网页。"><a href="#5-index-搜索引擎索引此网页。" class="headerlink" title="5.index : 搜索引擎索引此网页。"></a>5.index : 搜索引擎索引此网页。</h3><h3 id="6-follow-搜索引擎继续通过此网页的链接索引搜索其它的网页。"><a href="#6-follow-搜索引擎继续通过此网页的链接索引搜索其它的网页。" class="headerlink" title="6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。"></a>6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。</h3><h2 id="E-author"><a href="#E-author" class="headerlink" title="E.author"></a>E.author</h2><p>用于标注网页作者</p><meta name="author" content="希染，584297508@qq.com"><h2 id="F-generator-网页制作软件"><a href="#F-generator-网页制作软件" class="headerlink" title="F.generator(网页制作软件)"></a>F.generator(网页制作软件)</h2><meta name="generator" content="vscode"><h2 id="G-copyright-版权"><a href="#G-copyright-版权" class="headerlink" title="G.copyright(版权)"></a>G.copyright(版权)</h2><meta name="copyright" content="希染"><h2 id="H-revisit-after-重访"><a href="#H-revisit-after-重访" class="headerlink" title="H.revisit-after(重访)"></a>H.revisit-after(重访)</h2><p>如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问</p><meta name="revisit-after" content="7 days"><h2 id="I-renderer"><a href="#I-renderer" class="headerlink" title="I.renderer"></a>I.renderer</h2><p>renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说360浏览器。</p><p><meta name="renderer" content="webkit"> //默认webkit内核</p><p><meta name="renderer" content="ie-comp"> //默认IE兼容模式</p><p><meta name="renderer" content="ie-stand"> //默认IE标准模式</p><h1 id="http-equiv属性"><a href="#http-equiv属性" class="headerlink" title="http-equiv属性"></a>http-equiv属性</h1><p>http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 </p><h2 id="A-Expires-期限"><a href="#A-Expires-期限" class="headerlink" title="A.Expires(期限)"></a>A.Expires(期限)</h2><p>说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输</p><p><meta http-equiv="expires" content="Thu,06 Dec 2018 14:51:18 GMT"><br>注意：必须使用GMT的时间格式。 </p><h2 id="B-Pragma-cache模式"><a href="#B-Pragma-cache模式" class="headerlink" title="B.Pragma(cache模式)"></a>B.Pragma(cache模式)</h2><p>说明：禁止浏览器从本地计算机的缓存中访问页面内容。 </p><p><meta http-equiv="Pragma" content="no-cache"><br>注意：这样设定，访问者将无法脱机浏览。 </p><h2 id="C-Refresh-刷新"><a href="#C-Refresh-刷新" class="headerlink" title="C.Refresh(刷新)"></a>C.Refresh(刷新)</h2><p>说明：自动刷新并指向新页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2; URL = http://www.baidu.com&quot;&gt; (注意后面的引号，分别在秒数的前面和网址的后面)</span><br></pre></td></tr></table></figure></p><p>注意：其中的2是指停留2秒钟后自动刷新到URL网址 </p><h2 id="D-Set-Cookie-cookie设定"><a href="#D-Set-Cookie-cookie设定" class="headerlink" title="D.Set-Cookie(cookie设定)"></a>D.Set-Cookie(cookie设定)</h2><p>说明：如果网页过期，那么存盘的cookie将被删除。<br>用法：<meta http-equiv="Set-Cookie" content="cookie value=xxx;expires=Thu,06 Dec 2018 14:51:18 GMT;path=/"><br>注意：必须使用GMT的时间格式</p><h2 id="E-Window-target-显示窗口的设定"><a href="#E-Window-target-显示窗口的设定" class="headerlink" title="E.Window-target(显示窗口的设定)"></a>E.Window-target(显示窗口的设定)</h2><p>说明：强制页面在当前窗口以独立页面显示。<br>用法：<meta http-equiv="Window-target" content="_top"><br>注意：用来防止别人在框架里调用自己的页面</p><h2 id="F-content-Type-显示字符集的设定"><a href="#F-content-Type-显示字符集的设定" class="headerlink" title="F.content-Type(显示字符集的设定)"></a>F.content-Type(显示字符集的设定)</h2><p>说明：设定页面使用的字符集。<br>用法：<meta http-equiv="content-Type" content="text/html;charset=gb2312"><br>注意：HTML5中使用 <meta charset="utf-8"> 来设定<br>  meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文；<br>  meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文；<br>  meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文；<br>  meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文；<br>  meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文；<br>  meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码；</p><h2 id="G-content-Language（显示语言的设定）"><a href="#G-content-Language（显示语言的设定）" class="headerlink" title="G.content-Language（显示语言的设定）"></a>G.content-Language（显示语言的设定）</h2><p>用法：<meta http-equiv="Content-Language" content="zh-cn"> </p><h2 id="H-Cache-Control指定请求和响应遵循的缓存机制。"><a href="#H-Cache-Control指定请求和响应遵循的缓存机制。" class="headerlink" title="H.Cache-Control指定请求和响应遵循的缓存机制。"></a>H.Cache-Control指定请求和响应遵循的缓存机制。</h2><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，<br>响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。<br>各个消息中的指令含义如下<br> Public指示响应可被任何缓存区缓存<br> Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br> no-cache指示请求或响应消息不能缓存<br> no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br> max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br> min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br> max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="css" scheme="http://huangXin1538.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://huangXin1538.github.io/2018/11/28/20181128-1/"/>
    <id>http://huangXin1538.github.io/2018/11/28/20181128-1/</id>
    <published>2018-11-28T09:03:48.092Z</published>
    <updated>2019-03-04T07:21:53.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lt-lt-lt-lt-lt-lt-lt-mine"><a href="#lt-lt-lt-lt-lt-lt-lt-mine" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine</h2><p>title: html5新特性<br>date: 2018-11-28 17:03:48</p><h2 id="categories-html"><a href="#categories-html" class="headerlink" title="categories: html"></a>categories: html</h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>html5新特性盘点，面试常见</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="一-更多的语义标签"><a href="#一-更多的语义标签" class="headerlink" title="一.更多的语义标签"></a>一.更多的语义标签</h3><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。</p><ol><li><code>&lt;section&gt;&lt;/section&gt;</code>  定义文档中的主体部分的节、段</li><li><code>&lt;article&gt;&lt;/article&gt;</code>  一个特殊的section标签，比section有更明确的语义。定义来自外部的一个独立的、完整的内容块，例如什么论坛的文章，博客的文本</li><li><code>&lt;aside&gt;&lt;/aside&gt;</code>      页面中非正文的内容，独立于其他模块。例如广告、成组的链接、侧边栏</li><li><code>&lt;header&gt;&lt;/header&gt;</code>    定义文档、页面的页眉。通常是一些引导和导航信息，不局限于整个页面头部，也可以用在内容里</li><li><code>&lt;footer&gt;&lt;/footer&gt;</code>    定义了文档、页面的页脚，和header类似</li><li><code>&lt;nav&gt;&lt;/nav&gt;</code>          定义了一个链接组组成的导航部分，其中的链接可以链接到其他网页或者当前页面的其他部分</li><li><code>&lt;hgroup&gt;&lt;/hgroup&gt;</code>    用于对网页或区段(section)的标题元素(h1~h6)</li><li><code>&lt;details&gt;&lt;/details&gt;</code>  定义元素的细节，用户可以点击查看或者隐藏</li><li><code>&lt;summary&gt;&lt;/summary&gt;</code>  （译：摘要，一览） 和details连用，用来包含details的标题</li><li><code>&lt;canvas&gt;&lt;/canvas&gt;</code>  画布</li><li><code>&lt;video&gt;&lt;/video&gt;</code> </li><li><code>&lt;audio&gt;&lt;/audio&gt;</code></li><li><code>&lt;embed&gt;&lt;/embed&gt;</code>     （译：嵌入）定义嵌入网页的内容。比如插件。</li><li><code>&lt;source&gt;&lt;/source&gt;</code>   该标签为媒介元素(比如video、audio)定义媒介元素。</li><li><code>&lt;datalist id=&#39;dl&#39;&gt;&lt;/datalist&gt;</code>  定义可选数据的列表，与input配合使用(   <code>&lt;input list=&#39;dl&#39;&gt;</code>  )可制作输入值的下拉列表。</li><li><code>&lt;mark&gt;&lt;/mark&gt;</code>       在视觉上向用户展现出那些想要突出的文字。比如搜索结果中向用户高亮显示搜索关键词</li><li><code>&lt;progress&gt;&lt;/progress&gt;</code>  进度条，运行中的进度。</li><li><code>&lt;output&gt;&lt;/output&gt;</code>   定义不同类型的输出，样式与span相同</li><li><code>&lt;keygen&gt;&lt;/keygen&gt;</code>   定义加密内容</li><li><code>&lt;command&gt;&lt;/command&gt;</code> 定义命令行为</li><li><code>&lt;figure&gt;&lt;/figure&gt;</code>   独立于文章的内容，如果删除，对内容无影响</li><li><code>&lt;time&gt;&lt;/time&gt;</code>  定义时间和日期</li></ol><h3 id="二-本地存储（localStorage和sessionStorage）"><a href="#二-本地存储（localStorage和sessionStorage）" class="headerlink" title="二.本地存储（localStorage和sessionStorage）"></a>二.本地存储（localStorage和sessionStorage）</h3><ol><li><p>localStorage<br>存储大小：5M(cookie为4K)<br>兼容：ie8+ /Chrome 5+<br>特点：永久存储，不会被爬虫爬到，值类型限定为string，只在本地生效<br>读:<br>localStorage.getItem(‘name’)<br>localStorage.name<br>localStorage.key(‘name’)    //通过key值获取<br>删：<br>localStorage.removeItem(‘name’)<br>检测是否存在某个变量：<br>localStorage.hasOwnProperty(‘name’)  //hasOwnProperty为对象的方法，可以用来检测一个对象是否含有特定的自身属性</p></li><li><p>sessionStorage<br>与localStorage不同之处：<br>1.临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据<br>2.同源策略限制。若想在不同页面之间对同一个sessionStorage进行操作，这些页面必须在同一协议、同一主机名和同一端口下。(IE 8和9存储数据仅基于同一主机名，忽略协议（HTTP和HTTPS）和端口号的要求)<br>3.sessionStorage操作限制在单个标签页中，在此标签页进行同源页面访问都可以共享sessionStorage数据</p></li></ol><h3 id="三-离线web应用"><a href="#三-离线web应用" class="headerlink" title="三.离线web应用"></a>三.离线web应用</h3><p>页面缓存指的还是有网络状态下，而离线web应用指的是在没有网络状态可以运行应用</p><p>检测是否支持：</p><h2 id><a href="#" class="headerlink" title="======="></a>=======</h2><p>title: ‘html5新特性’<br>date: 2018-11-28 17:03:48</p><h2 id="categories-html-1"><a href="#categories-html-1" class="headerlink" title="categories: html"></a>categories: html</h2><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>html5新特性盘点，面试常见</p><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><h3 id="一-更多的语义标签-1"><a href="#一-更多的语义标签-1" class="headerlink" title="一.更多的语义标签"></a>一.更多的语义标签</h3><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。</p><ol><li><code>&lt;section&gt;&lt;/section&gt;</code>  定义文档中的主体部分的节、段</li><li><code>&lt;article&gt;&lt;/article&gt;</code>  一个特殊的section标签，比section有更明确的语义。定义来自外部的一个独立的、完整的内容块，例如什么论坛的文章，博客的文本</li><li><code>&lt;aside&gt;&lt;/aside&gt;</code>      页面中非正文的内容，独立于其他模块。例如广告、成组的链接、侧边栏</li><li><code>&lt;header&gt;&lt;/header&gt;</code>    定义文档、页面的页眉。通常是一些引导和导航信息，不局限于整个页面头部，也可以用在内容里</li><li><code>&lt;footer&gt;&lt;/footer&gt;</code>    定义了文档、页面的页脚，和header类似</li><li><code>&lt;nav&gt;&lt;/nav&gt;</code>          定义了一个链接组组成的导航部分，其中的链接可以链接到其他网页或者当前页面的其他部分</li><li><code>&lt;hgroup&gt;&lt;/hgroup&gt;</code>    用于对网页或区段(section)的标题元素(h1~h6)</li><li><code>&lt;details&gt;&lt;/details&gt;</code>  定义元素的细节，用户可以点击查看或者隐藏</li><li><code>&lt;summary&gt;&lt;/summary&gt;</code>  （译：摘要，一览） 和details连用，用来包含details的标题</li><li><code>&lt;canvas&gt;&lt;/canvas&gt;</code>  画布</li><li><code>&lt;video&gt;&lt;/video&gt;</code> </li><li><code>&lt;audio&gt;&lt;/audio&gt;</code></li><li><code>&lt;embed&gt;&lt;/embed&gt;</code>     （译：嵌入）定义嵌入网页的内容。比如插件。</li><li><code>&lt;source&gt;&lt;/source&gt;</code>   该标签为媒介元素(比如video、audio)定义媒介元素。</li><li><code>&lt;datalist id=&#39;dl&#39;&gt;&lt;/datalist&gt;</code>  定义可选数据的列表，与input配合使用(   <code>&lt;input list=&#39;dl&#39;&gt;</code>  )可制作输入值的下拉列表。</li><li><code>&lt;mark&gt;&lt;/mark&gt;</code>       在视觉上向用户展现出那些想要突出的文字。比如搜索结果中向用户高亮显示搜索关键词</li><li><code>&lt;progress&gt;&lt;/progress&gt;</code>  进度条，运行中的进度。</li><li><code>&lt;output&gt;&lt;/output&gt;</code>   定义不同类型的输出，样式与span相同</li><li><code>&lt;keygen&gt;&lt;/keygen&gt;</code>   定义加密内容</li><li><code>&lt;command&gt;&lt;/command&gt;</code> 定义命令行为</li><li><code>&lt;figure&gt;&lt;/figure&gt;</code>   独立于文章的内容，如果删除，对内容无影响</li><li><code>&lt;time&gt;&lt;/time&gt;</code>  定义时间和日期</li></ol><h3 id="二-本地存储（localStorage和sessionStorage）-1"><a href="#二-本地存储（localStorage和sessionStorage）-1" class="headerlink" title="二.本地存储（localStorage和sessionStorage）"></a>二.本地存储（localStorage和sessionStorage）</h3><ol><li><p>localStorage<br>存储大小：5M(cookie为4K)<br>兼容：ie8+ /Chrome 5+<br>特点：永久存储，不会被爬虫爬到，值类型限定为string，只在本地生效<br>读:<br>localStorage.getItem(‘name’)<br>localStorage.name<br>localStorage.key(‘name’)    //通过key值获取<br>删：<br>localStorage.removeItem(‘name’)<br>检测是否存在某个变量：<br>localStorage.hasOwnProperty(‘name’)  //hasOwnProperty为对象的方法，可以用来检测一个对象是否含有特定的自身属性</p></li><li><p>sessionStorage<br>与localStorage不同之处：<br>1.临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据<br>2.同源策略限制。若想在不同页面之间对同一个sessionStorage进行操作，这些页面必须在同一协议、同一主机名和同一端口下。(IE 8和9存储数据仅基于同一主机名，忽略协议（HTTP和HTTPS）和端口号的要求)<br>3.sessionStorage操作限制在单个标签页中，在此标签页进行同源页面访问都可以共享sessionStorage数据</p></li></ol><h3 id="三-离线web应用-1"><a href="#三-离线web应用-1" class="headerlink" title="三.离线web应用"></a>三.离线web应用</h3><p>页面缓存指的还是有网络状态下，而离线web应用指的是在没有网络状态可以运行应用</p><p>检测是否支持：</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>.theirs</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;lt-lt-lt-lt-lt-lt-lt-mine&quot;&gt;&lt;a href=&quot;#lt-lt-lt-lt-lt-lt-lt-mine&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; .mine&quot;&gt;&lt;/a&gt;&amp;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js非构造函数继承（持续更新）</title>
    <link href="http://huangXin1538.github.io/2018/10/23/20181023-1/"/>
    <id>http://huangXin1538.github.io/2018/10/23/20181023-1/</id>
    <published>2018-10-23T09:19:57.000Z</published>
    <updated>2019-03-04T01:54:50.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天整理了一下js含构造函数的对象实现继承的方式，今天整理下非构造函数的继承</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-object方法"><a href="#1-object方法" class="headerlink" title="1.object方法"></a>1.object方法</h3><p>json格式的发明人Douglas Crockford，提出了一个object()函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">　　F.prototype = o;</span><br><span class="line">　　<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="keyword">var</span> Chinese = &#123;</span><br><span class="line">　　nation:<span class="string">'中国'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Doctor = &#123;</span><br><span class="line">    career:<span class="string">'医生'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Doctor = object(Chinese);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Doctor.nation) <span class="comment">//中国</span></span><br></pre></td></tr></table></figure></p><h3 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2.浅拷贝"></a>2.浅拷贝</h3><p>把父对象的属性拷贝给子对象，实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123; </span><br><span class="line">　　　　c[i] = p[i];</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line"><span class="keyword">var</span> Doctor = extendCopy(Chinese);</span><br><span class="line">Doctor.career = <span class="string">'医生'</span>;</span><br><span class="line">alert(Doctor.nation); <span class="comment">// 中国</span></span><br></pre></td></tr></table></figure><p>这样的做法存在一个问题，如果父元素的属性中存在数组或者对象，拷贝过来的只是一个内存地址指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果给chinese对象添加一条属性</span><br><span class="line"></span><br><span class="line">Chinese.birthPlaces = [<span class="string">'北京'</span>,<span class="string">'上海'</span>,<span class="string">'香港'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Doctor = extendCopy(Chinese);</span><br><span class="line"></span><br><span class="line">Doctor.birthPlace.push(<span class="string">'厦门'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(chinese.birthPlace) <span class="comment">//['北京','上海','香港','厦门']</span></span><br></pre></td></tr></table></figure><p>如果修改Doctor.birthPlace,内存地址指向的数组被修改,chinese中的birthPlace也被修改，显然不符合预期</p><h3 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3.深拷贝"></a>3.深拷贝</h3><p>递归调用浅拷贝，即可实现深拷贝<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Doctor = deepCopy(Chinese);</span><br><span class="line">Chinese.birthPlaces = [<span class="string">'北京'</span>,<span class="string">'上海'</span>,<span class="string">'香港'</span>];</span><br><span class="line">Doctor.birthPlaces.push(<span class="string">'厦门'</span>);</span><br><span class="line">alert(Doctor.birthPlaces); <span class="comment">//北京, 上海, 香港, 厦门</span></span><br><span class="line">alert(Chinese.birthPlaces); <span class="comment">//北京, 上海, 香港</span></span><br></pre></td></tr></table></figure></p><p>深拷贝后，birthPlace属性在doctor中就是独立存在的一个属性，而不是一个内存指向了，所以对doctor的任何操作都不会对chinese有任何影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;昨天整理了一下js含构造函数的对象实现继承的方式，今天整理下非构造函数的继承&lt;/p&gt;
&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; c
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js构造函数的继承（持续更新）</title>
    <link href="http://huangXin1538.github.io/2018/10/22/20181022-1/"/>
    <id>http://huangXin1538.github.io/2018/10/22/20181022-1/</id>
    <published>2018-10-22T10:00:11.000Z</published>
    <updated>2019-03-04T01:54:47.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近复习js基本原理，毕竟什么框架都是建立在js的基础上的，js精通，框架又有何难。<br>趁着有时间整理一下js实现继承的方式。</p><h2 id="具体方式"><a href="#具体方式" class="headerlink" title="具体方式"></a>具体方式</h2><h3 id="1-构造函数绑定"><a href="#1-构造函数绑定" class="headerlink" title="1.构造函数绑定"></a>1.构造函数绑定</h3><p>最简单，使用call和apply，将父对象的构造函数绑定到子对象身上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> cat(<span class="string">'大毛'</span>,<span class="string">'红色'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat1.species)</span><br></pre></td></tr></table></figure><h3 id="2-prototype模式"><a href="#2-prototype模式" class="headerlink" title="2.prototype模式"></a>2.prototype模式</h3><p>将cat的prototype指向Animal实例，那么所有的cat对象都拥有animal的属性，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向cat的；加了这一行以后，cat.prototype.constructor指向Animal。</p><p>每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！<br>cat实例是由构造函数cat生成的，为了保证继承链的稳定，手动纠正，将constructor指回cat<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">cat.prototype.constructor = cat;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果没有将<span class="keyword">constructor</span>手动纠正，那么</span><br><span class="line"></span><br><span class="line">cat1.prototype.<span class="keyword">constructor</span> = Animal;</span><br><span class="line">纠正后</span><br><span class="line">cat1.prototype.<span class="keyword">constructor</span> = cat;</span><br></pre></td></tr></table></figure></p><h3 id="3-利用空对象做中介"><a href="#3-利用空对象做中介" class="headerlink" title="3.利用空对象做中介"></a>3.利用空对象做中介</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Animal.prototype;</span><br><span class="line">cat.prototype = <span class="keyword">new</span> F();</span><br><span class="line">cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><p>F是空对象，所以几乎不占内存。这时，修改cat的prototype对象，就不会影响到Animal的prototype对象。</p><p>将上述操作进行封装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">　　F.prototype = Parent.prototype;</span><br><span class="line">　　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">　　Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">extend(cat,animal);</span><br><span class="line">cat继承animal属性</span><br></pre></td></tr></table></figure></p><h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h3><p>原理为，将父对象所有属性拷贝进字对象实现继承。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">child,parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = parent.prototype;</span><br><span class="line">　　<span class="keyword">var</span> c = child.prototype;</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　c[i] = p[i];</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">extend2(cat, animal);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近复习js基本原理，毕竟什么框架都是建立在js的基础上的，js精通，框架又有何难。&lt;br&gt;趁着有时间整理一下js实现继承的方式。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中五种检测数据类型方法</title>
    <link href="http://huangXin1538.github.io/2018/10/19/20181019-1/"/>
    <id>http://huangXin1538.github.io/2018/10/19/20181019-1/</id>
    <published>2018-10-19T03:05:26.000Z</published>
    <updated>2019-03-04T01:54:43.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司项目不多，静下心来整理一些东西（不加班的feel倍儿爽）。<br>js判断数据类型算是很常用的代码了，不管是项目中还是面试，必不可少啊，值得一记。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-typeOf"><a href="#1-typeOf" class="headerlink" title="1.typeOf"></a>1.typeOf</h3><p>typeOf 为一个一元运算符，放在一个运算数之前，运算数可以是任何类型。<br>返回结果为一个字符串，该字符串对应运算数的数据类型。</p><p>用法：typeOf + 运算数 或 typeOf (运算数)</p><p>结果展示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol 有效，symbol为es6中第七种数据类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">''</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> [] ; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure></p><p>注意：<br>typeof null 的问题<br>不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判<br>断为 object 类型， null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“ object ”,typeOf对null束手无策。</p><p>typeOf [] 的问题<br>JS中因为数组也是属于对象的，所以判断是不是数组，typeOf表示：不好办啊</p><p>同理，日期类型Date()和正则表达式RegExp() 也是属于对象,所以Date()/RegExp()/[]/null 不能用typeOf来检测</p><h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h3><p>用法： object instanceof constructor</p><p>instanceof 同为一元运算符，用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性</p><p>看起来比较绕，上例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br></pre></td></tr></table></figure></p><p>instanceof 可以检测 某个对象是否为数组、日期、regexp() 类型</p><p>注意：<br>因为undefined 和null 类型，访问不到内部，所以不能用instanceof判断</p><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h3><p>constructor作用和instanceof非常相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;</span><br><span class="line">a.constructor===<span class="built_in">String</span>;<span class="comment">//true</span></span><br><span class="line">a.constructor===<span class="built_in">Array</span>;<span class="comment">//false</span></span><br><span class="line">a.constructor===<span class="built_in">RegExp</span>;<span class="comment">//false</span></span><br><span class="line">(<span class="number">1</span>).constructor===<span class="built_in">Number</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[0-9]/</span>;</span><br><span class="line">reg.constructor===<span class="built_in">RegExp</span>;<span class="comment">//true</span></span><br><span class="line">reg.constructor===<span class="built_in">Object</span>;<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>注意：<br>1.constructor 不能用于判断null和undefined （不存在constructor）<br>2.如果object被重新覆盖，检测结果就会不准确</p><h3 id="4-严格运算符"><a href="#4-严格运算符" class="headerlink" title="4.严格运算符 ==="></a>4.严格运算符 ===</h3><p>只能用于判断null 和 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// "object"</span></span><br><span class="line">a === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="5-Object-prototype-toString-call"><a href="#5-Object-prototype-toString-call" class="headerlink" title="5.Object.prototype.toString.call()"></a>5.Object.prototype.toString.call()</h3><p>这个方法就比较花里胡哨了，在以前的项目中也基本没用过这个方式。</p><p>toString方法，在Object原型上的返回，是数据的格式。因为不同类型的toString方法，都被重写。<br>所以obj.toString和Object.prototype.toString.call(obj)的结果不同。</p><p>优点：可以判断所有类型<br>缺点：得到的结果为’[object String]’类型的字符串，需要处理一下格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"jerry"</span>));<span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">12</span>));     <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>));   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>));<span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>));   <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">name</span>: <span class="string">"jerry"</span>&#125;));<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));    <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]));        <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>));        <span class="comment">//[object Date]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/\d/</span>));        <span class="comment">//[object RegExp]</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，可以得出结论</p><p>Symbol、string、number、boolean、function、undefined  使用 typeOf()</p><p>null、[]、obj、Date()、RegExp()  使用instanceof </p><p>或者所有的类型检测都用Object.prototype.toString.call(),更有逼格。</p><p>即可做到正确检测。<br>就酱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司项目不多，静下心来整理一些东西（不加班的feel倍儿爽）。&lt;br&gt;js判断数据类型算是很常用的代码了，不管是项目中还是面试，必不可少
      
    
    </summary>
    
    
      <category term="js" scheme="http://huangXin1538.github.io/tags/js/"/>
    
  </entry>
  
</feed>
