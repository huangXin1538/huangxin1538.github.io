<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何使用pixi制作'打飞机'小游戏]]></title>
    <url>%2F2019%2F05%2F30%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8pixi%E5%88%B6%E4%BD%9C%E2%80%98%E6%89%93%E9%A3%9E%E6%9C%BA%E2%80%99%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[什么是pixi.jsPixi.js使用WebGL，是一个超快的HTML5 2D渲染引擎。作为一个Javascript的2D渲染器，Pixi.js的目标是提供一个快速的、轻量级而且是兼任所有设备的2D库。提供无缝 Canvas 回退，支持主流浏览器，包括桌面和移动。 Pixi渲染器可以开发者享受到硬件加速，但并不需要了解WebGL。 如何引入pixi.js1.安装模块代码中引入：import * as PIXI from ‘pixi.js’;2.cdn 创建pixi实例完整流程1.创建一个应用(application)(包含舞台stage)2.加载资源（loader）3.创建游戏场景4.将场景插入舞台(addchild)5.把画布插入dom（append）6.创建精灵（sprite）7.把精灵加入画布（addchild）8.刷新舞台（ticker）9.游戏结束，销毁应用（destroy） 1.创建应用1234567let gameApp = new PIXI.Application(&#123; width: xxxx, height: xxxx, antialiasing: true, // 抗锯齿 transparent: false, // 背景透明 resolution: 2 // 渲染倍数，避免模糊&#125;); 2.加载资源12345678let loader = new PIXI.Loader();loader .add('bg', 'img/bg.jpg') ..... .load((loader, resources) =&gt; &#123; // 加载完毕回调 setUp(); //执行创建精灵等操作 &#125;); 3/4.创建游戏场景并插入舞台1234let gameScene = new PIXI.Container();gameScene.width = xxx;gameScene.height = xxx;gameApp.stage.addchild(gameScene); 5.把画布插入dom1document.getElementById('xxx').appendChild(gameApp.view); 6.创建精灵并插入场景首先，为了方便的设定精灵宽高，声明两个方法12345678function getWidth (precent) &#123; let w = document.body.clientWidth &gt; 720 ? 720 : document.body.clientWidth; return (precent / 50) * w / 2;&#125;function getHeight (precent) &#123; let h = document.body.clientHeight; return (precent / 50) * h / 2;&#125; 1.背景123456let bg = new PIXI.Sprite(resources.bg.texture);bg.width = xxx;bg.height = xxx;bg.x = xxx;bg.y = xxx;gameScene.addchild(bg) 2.飞机123456let plane = new PIXI.Sprite(resources.plane.texture);plane.width = xxx;plane.height = xxx;plane.x = xxx;plane.y = xxx;gameScene.addchild(plane) 给飞机添加拖动事件，让飞机跟着手指移动。给飞机添加射击事件，在ticker中调用，使飞机一直发射子弹3.障碍物123456let obstacle = new PIXI.Sprite(resources.obstacle.texture);obstacle.width = xxx;obstacle.height = xxx;obstacle.x = xxx;obstacle.y = xxx;gameScene.addchild(obstacle) 这种只是最基础的做法，如果有稍微多一点的需求，例如，碰撞检测的区域，和纹理图大小不一样，就需要将障碍物纹理、碰撞区域、爆炸动画，都放入一个container内，碰撞区域push进入obstacles数组，去和子弹飞机做碰撞检测障碍物的飞行，使用tween.js,初始化时候，设置好起点终点，在ticker中update就可以像目的地移动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182let container = new PIXI.Container();// 图案let obstacle = new PIXI.Sprite(texture.obstacle.texture);obstacle.name = 'obstacle';obstacle.width = getWidth(30);obstacle.height = getWidth(30);obstacle.x = 0;obstacle.y = 0;obstacle.anchor.set(0.5, 0.5);// 碰撞区域let circle = new PIXI.Sprite();circle.width = obstacle.width * 0.5;circle.height = circle.width;circle.name = 'circle';circle.circular = true;circle.x = -circle.width*0.5;circle.y = -circle.height*0.5;container.addChild(circle);// 文字let text = new PIXI.Text('哈哈', &#123; fontSize: obstacle.width * 0.13, fill: '#fff'&#125;);text.x = - text.width*0.5;text.y = - text.height*0.5;container.addChild(text);// 爆炸效果let fireClip = [];for (let i = 0; i &lt;= 23; i++) &#123; fireClip.push(texture.boom.textures['boom' + i + '.png']);&#125;let boom = new PIXI.AnimatedSprite(fireClip);boom.width = obstacle.width * 2.5;boom.height = obstacle.height * 2.5;boom.x = -boom.width * 0.5;boom.y = -boom.height * 0.5;boom.name = 'boom';boom.loop = false;container.addChild(boom);container.addChild(obstacle);container.addChild(circle);container.x = getWidth(Math.random()*100);container.y = -obstacle.height; // 位移设定let tween = new TWEEN.Tween(container) .to( &#123; x: getWidth(Math.random() * 100), y: getHeight(100) + obstacle.height, &#125;, obstacleTime // tween持续时间 ) .easing(TWEEN.Easing.Linear.None) .onComplete(function () &#123; // 到底 container.destroy(); &#125;);tween.start();// 旋转设定let tween2 = new TWEEN.Tween(obstacle) .to( &#123; rotation: -20 &#125;, obstacleTime // tween持续时间 ) .easing(TWEEN.Easing.Linear.None) .onComplete(function () &#123; &#125;);tween2.start();// 插入场景container.tween = tween;obstacles.push(circle);tweens.push(tween);gameScene.addChild(container); 7.更新舞台创建完游戏内所有元素后，开启pixi内置定时器ticker123app.ticker.add(function () &#123; return gameLoop();&#125;); 在ticker中更新需要调用的事件，来实现游戏的动态效果12345678910function gameLoop()&#123; // 生成子弹 plane.shut(gameScene, bullets); // 生成障碍物 createobstacle(gameScene, texture, obstacles, TWEEN, tweens); // 子弹逻辑处理 bulletsEvents(); // 障碍物逻辑处理 obstaclesEvents();&#125; 8.子弹飞机障碍物的碰撞逻辑（重点）1234567891011121314151617181920212223242526272829303132333435363738394041function bulletsEvents()&#123; for(let i = 0; i &lt; bullets.length;)&#123; let hit = false; for(let o = 0; o &lt; obstacles.length; ) &#123; // 子弹与障碍物碰撞检测 if(hitTest(obstacles[o], bullets[i])) &#123; hit = true; // 移除障碍物 obstaclesBoom(o) continue; &#125;else if(hitTest(obstacles[o], plane))&#123; // 飞机与障碍物碰撞检测 let _obstacle = obstacles.splice(o,1)[0]; _obstacle.destroy(); gameOver(); continue; &#125;else&#123; o++ &#125; &#125; // 根据碰撞状态做处理 if(hit)&#123; // 如果碰撞了 // 移除当前子弹 let _bullet = bullets.splice(i,1)[0]; _bullet.destroy(); // 加分 score ++; scorePanel.text = '得分：' + score; &#125;else&#123; // 如果子弹飞出屏幕，则移除；如果没有，Y轴位移 if(bullets[i].y &lt; -bullets[i].height)&#123; let _bullet = bullets.splice(i,1)[0]; _bullet.destroy(); &#125;else&#123; bullets[i].y -= 10; i++ &#125; &#125; &#125;&#125; 首先遍历子弹池，内部遍历所有障碍物，通过hitTest做碰撞检测如果子弹和障碍物碰撞，子弹消失，障碍物消失/爆炸，得分+1；如果飞机和障碍物碰撞，障碍物消失/爆炸，游戏结束如果都没有，检测下一个子弹 如果子弹自下而上，飞出屏幕，则子弹移除，否则影响性能碰撞检测代码，bump通过cdn引入hitTestCircleRectangle只能用于圆形和矩形的碰撞，更多方式查看PIXI官方文档12345678910// 子弹词条碰撞import * as PIXI from 'pixi.js';export function hitTest (r1, r2) &#123; let b = new Bump(PIXI); if (b.hitTestCircleRectangle(r1, r2, true) !== false) &#123; return true; &#125; else &#123; return false; &#125;&#125; 9.障碍物爆炸逻辑碰撞之后，根据parent属性，找到container，进而找到内部的爆炸动画，执行play()方法；爆炸的同时，使纹理隐藏，形成视觉上的碰撞爆炸效果 部分代码：12345678function obstaclesBoom(o)&#123; let container = obstacles[o].parent; let _obstacle = obstacles.splice(o,1)[0]; _obstacle.destroy(); container.children[1].play(); container.children[0].visible = false; container.children[2].visible = false;&#125; 总结只是随便讲一下做法的逻辑，具体代码已上传github，地址：https://github.com/huangXin1538/pixi-aircrift-wars就酱~]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue双向绑定原理]]></title>
    <url>%2F2019%2F05%2F28%2Fvue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[原理vue数据双向绑定通过‘数据劫持’ + 订阅发布模式实现 数据劫持指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果 典型的有1.Object.defineProperty()2.es6中Proxy对象 vue2.x使用Object.defineProperty();vue3.x使用Proxy; 订阅发布模式定义：对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知订阅发布模式中事件统一由处理中心处理，订阅者发布者互不干扰。优点：实现更多的控制，做权限处理，节流控制之类，例如：发布了很多消息，但是不是所有订阅者都要接收 12345678910111213141516171819202122232425// 实现一个处理中心let event = &#123; clientList: &#123;&#125;, // 订阅事件列表 // 订阅 on(key, fn)&#123; // 如果这个事件没有被订阅，那么创建一个列表用来存放事件 if(!this.clientList[key]) &#123; this.clientList[key] = [] &#125; // 将事件放入已有的事件列表中 this.clientList[key].push(fn); &#125;, // 发布 trigger(type, args)&#123; let fns = this.clientList[type] // 拿到这个事件的所有监听 if(!fns || fns.length === 0)&#123; // 如果没有这条消息的订阅者 return false &#125; // 如果存在这个事件的订阅，那么遍历事件列表，触发对应监听 fns.forEach(fn =&gt; &#123; // 可以在此处添加过滤等处理 fn(args) &#125;) &#125;&#125; vue中如何实现利用Object.defineProperty();把内部解耦为三部分Observer: 递归的监听对象上的所有属性，当属性改变时触发对应的watcherwatcher(观察者):当蒋婷的数据值修改时，执行相应的回调函数，更新模板内容dep：链接observer和watcher，每一个observer对应一个dep,内部维护一个数组，保存与该observer相关的watcher]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js手写简单双向绑定]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%89%8B%E5%86%99%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[什么是双向绑定1.当一个对象（或变量）的属性改变，那么调用这个属性地方也应该改变，模型到视图（model =&gt; view）2.当调用属性的这个地方改变了这个属性（通常是一个表单元素），那么这个对象（或变量）的属性也随之改变，即视图到模型（view =&gt; model） 如何实现（怎么知道对象的属性变了）Object.defineProperty 设置对象属性的描述字段里面有两个属性set(设置属性时被调用)和get（获取属性时被调用）input检测属性值的改变，触发后对应修改对应的对象（或变量）例：12345678910111213141516171819202122232425262728293031323334&lt;body&gt; 手写一个简单双向绑定&lt;br/&gt; &lt;input type="text" id="model"&gt;&lt;br/&gt; &lt;div id="modelText"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var user = &#123; name: '希染' &#125;; var defaultName = '希染' var input = document.querySelector("#model"); var text = document.querySelector("#modelText"); input.value = user.name; text.textContent = user.name; // 数据到视图 model =&gt; view Object.defineProperty(user,"name",&#123; get:function()&#123; console.log('获取user') &#125;, set:function(val)&#123; console.log('修改user') input.value = val; text.textContent = val; &#125; &#125;) // 视图到数据 view =&gt; model input.addEventListener('input',function(val)&#123; user.name = input.value; &#125;)&lt;script&gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇到过的问题]]></title>
    <url>%2F2019%2F05%2F21%2F%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.自定义视频播放按钮，播放后设置播放按钮隐藏，但是切屏后返回，按钮又出现原因：切屏时，视频自动暂停，触发了onpause回调，导致播放按钮出现；返回时，视频自动继续播放，没有走按钮的点击事件解决：添加视频onplay监听，如果视频播放，就隐藏播放按钮]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组去重方式]]></title>
    <url>%2F2019%2F05%2F14%2Fjs%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Set：数据结构，类似数组，成员唯一…：（展开/剩余）运算符，展开数组和对象； …使用1234//展开let a = [1,2,3];console.log(...a);输出： 1 2 3 Set使用1234let a = [1,1,1,1,2,2,2]let b = new Set(a)输出b: Set&#123;1,2&#125; 结合两者123var a = [1,2,2,2,3];a = [...new Set(a)];输出 a = [1,2]; 首先 new Set(a) 为 Set{1,2}然后…将 new Set(a)展开，为: 1 2最后，放入a中，实现去重]]></content>
  </entry>
  <entry>
    <title><![CDATA[es6解构赋值]]></title>
    <url>%2F2019%2F04%2F18%2Fes6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[基本用法：es6允许按照一定模式，从对象和数组中提取值，对变量进行赋值，被称为解构赋值 12let [a, b, c] = [1, 2, 3];// a=1;b=2;c=3 只要等号两边的模式相同，左边的变量就会被赋予对应的值 Set 结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 注意点：（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重绘和回流]]></title>
    <url>%2F2019%2F04%2F17%2F%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%2F</url>
    <content type="text"><![CDATA[重绘当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少 常见重绘操作有：1.改变元素颜色2.改变元素背景色3.。。。。。。 回流（重排）当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新计算，计算后还需要重新布局页面，因此是较重的操作。 常见回流操作有：1.页面初次渲染2.浏览器窗口大小改变3.元素尺寸、位置、内容发生改变4.元素字体大小变化5.添加或删除可见的DOM6.激活css伪类（：hover）7.。。。。。。 总结回流必定触发重绘，重绘不一定触发回流。回流开销较大。 如何避免大量使用重绘和回流 1.避免频繁操作样式，可汇总后统一修改2.尽量使用class进行样式修改，而不是直接插入样式3.减少dom操作。可使用字符串一次插入]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js节流和防抖]]></title>
    <url>%2F2019%2F04%2F17%2F%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[意义在进行窗口的 resize、scroll、输入框内容验证、touchmove 等操作时，如果事件处理函数调用的频率无限制，会加重浏览器负担，甚至卡死。导致用户体验很糟糕。此时可以采用 debounce（防抖）和 throttle（节流）的方式减少调用频率，同时不影响实际效果 防抖防抖：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次。如果设定的事件到来之前，又触发了事件，就重新开始延时例： 12345678910111213function debounce(fn, wait) &#123; var timeout = null; return function() &#123; if (timeout !== null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;;&#125;// 处理函数function handle() &#123; console.log(Math.random());&#125;// 滚动事件window.addEventListener("scroll", debounce(handle, 1000)); 节流当持续触发事件时，保证一定时间段内只调用一次事件处理函数。例如。当持续触发 scroll 事件时，并不立即执行回调，每隔 1s 才会执行一次 1.时间戳方式实现12345678910111213141516var throttle = function(func, delay) &#123; var prev = Date.now(); return function() &#123; var context = this; var args = arguments; var now = Date.now(); if (now - prev &gt;= delay) &#123; func.apply(context, args); prev = Date.now(); &#125; &#125;;&#125;;function handle() &#123; console.log(Math.random());&#125;window.addEventListener("scroll", throttle(handle, 1000)); 2.定时器方式实现1234567891011121314151617var throttle = function(func, delay) &#123; var timer = null; return function() &#123; var context = this; var args = arguments; if (!timer) &#123; timer = setTimeout(function() &#123; func.apply(context, args); timer = null; &#125;, delay); &#125; &#125;;&#125;;function handle() &#123; console.log(Math.random());&#125;window.addEventListener("scroll", throttle(handle, 1000)); 总结函数防抖：讲几次操作合为一次操作进行。原理是维护一个定时器，规定在delay时间后触发，但是在delay时间内再次触发，就会取消之前的定时器重新设置。这样一来，只有最后一次才能触发 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数 区别： 函数节流不管事件触发多频繁，都会保证在规定时间内一定会触发一次函数 防抖只是在最后一次事件后才触发一次函数 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次ajax，而不是在用户停下时才去请求。这样的场景适合用节流 页面缩放修改rem设定，适合用防抖]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js字符串方法]]></title>
    <url>%2F2019%2F04%2F09%2Fjs%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[charAt()返回指定索引位置的字符 charCodeAt()返回指定索引位置的Unicode值 concat()连接两个或多个字符串，返回连接后的字符串 fromCharCode()将Unicode转换为字符串 indexOf()返回字符串中指定字符第一次出现的位置 lastIndexOf()最后一次出现的位置 localeCompare()用本地特定的顺序来比较两个字符串 match()找到一个或多个正则表达式的匹配 replace()替换与正则表达式匹配的字符串 search()检索与正则表达式匹配的值 slice()提取字符串的片段，并在新的字符串中返回被提取的部分 split(分隔符)按分隔符把字符串分割为数组 substr(start,length)从起始索引号提取字符串中指定数目的字符 substring(from,to)提取字符串中两个指定的索引号之间的字符 toLowerCase()‘ABC’.toLocaleLowerCase() //abc转为小写,不会改变原字符串 toUpperCase()‘abc’.toLocaleLowerCase() //ABC转为大写,不会改变原字符串 trim()删除字符串首尾空格str.trim();不会改变原字符串]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组方法]]></title>
    <url>%2F2019%2F04%2F09%2Fjs%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[concat 合并arr1.concat(arr2) entries该方法返回一个新的Array Iterator（迭代器）对象，该对象包含数组中每个索引对应的键/值对123456789101112var a = ['a','b','c']var iterator = a.entries()console.log(iterator) // Array Iterator&#123;&#125;console.log(iterator.next().value) // [0,'a']或者for(let a of iterator)&#123; console.log(a)&#125;//[0,'a']//[1,'b']//[2,'c'] every()array.every(function(currentValue,index,arr), thisValue)检测数组中每个元素是否符合筛选条件；参数1：function(每一个元素) 必传 2：thisValue 可选返回 true/false fill()array.fill(value, start, end)将数组中元素都替换成固定值 filter()过滤出符合条件的元素，组成新数组并返回array.filter(function(currentValue,index,arr), thisValue) 1.不会对空数组检测2.不会改变原数组 find()获取数组中第一个符合条件的值array.find(function(currentValue, index, arr),thisValue) 找不到返回undefined findIndex()获取数组中第一个符合条件的值，返回所在位置array.findIndex(function(currentValue, index, arr),thisValue)找不到返回-1 forEach()遍历数组array.forEach(function(currentValue, index, arr), thisValue) includes()判断数组中是否包含一个指定的值arr.includes(searchElement, fromIndex) 返回true/false indexOf()array.indexOf(item,start)返回数组中某个指定元素的位置找不到返回-1 join()array.join(分隔符); //不传就是没有分隔数组中所有元素放入一个字符串并返回 keys()从数组创建一个包含数组键的可迭代对象array.keys();返回： Array Iteratorfor(let a of array.keys()){ console.log(a)}log出索引值 lastIndexOf()获取数组中第一个符合条件的值，返回所在位置，倒序array.lastIndexOf(); map()返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值array.map(function(currentValue,index,arr), thisValue) pop()删除数组中最后一个元素，并返回array.pop(); push()向数组末添加一个或多个元素，返回新长度array.push(newelement1,newelement2,….,newelementX) reduce()接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值array.reduce(function(total, currentValue, currentIndex, arr), initialValue)高阶函数，可用于compose reduceRight()从右边开始reduce reverse()翻转数组并返回 shift()删除数组中第一个元素，并返回该元素会改变数组长度 splice()array.splice(index,howmany,item1,…..,itemX)按照指定位置，删除数组中的元素；第三个以后参数，可以在删除位置添加元素 some()用法同every()，区别为every：每一项都为true，才返回true;some: 任一项为true，就返回true sort()array.sort(sortfunction(a,b))对数组进行排序,a,b为前后两个元素，return a&gt;b;升序，return a&lt; b 降序； slice()array.slice(start,end);从已有数组中选出指定元素，并放进一个数组返回不会改变原数组 toString()[0,1].toString = ‘0,1’ unshift()想数组开头添加一个或多个元素，返回新长度arrayObject.unshift(newelement1,newelement2,….,newelementX)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型]]></title>
    <url>%2F2019%2F04%2F09%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本类型：String（字符型）、Number（数字型）、Boolean(布尔型)、undefined、null 引用类型：Object（包括function/array）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2019%2F04%2F02%2F20190402-2%2F</url>
    <content type="text"><![CDATA[js 内存回收机制 和 闭包定义一个函数在执行开始的时候，会给其中定义的变量划分内存空间保存，以备后面的语句所用，等到函数执行完毕，这些变量就被认为是无用的，对应的空间会被收回。 下次再执行这个函数的时候，所有的变量又回到了最初的的状态，重新赋值使用。 但是当一个函数内部又嵌套了一个函数，而这个函数是有可能在外部被调用到的。并且这个内部函数又使用了外部函数的某些变量的话，这种内存回收机制就会出现问题。如果在外部函数返回后，又直接调用了内部函数。那么内部函数就无法读取他所需要的外部函数中的变量的值了。 所以js解释器在遇到函数定义的时候会自动把函数和他可能使用的变量一起保存下来。也就形成一个闭包。这些变量不会被内存回收，只有当内部的函数不可能被调用以后（例如被删除、没有了指针），才会销毁这个闭包，而没有任何一个闭包引用的变量才会被下一次内存回收启动时回收。 闭包特性 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被回收 闭包好处 1.希望一个变量长期存储在内存中 2.避免全局变量的污染 3.私有成员的存在 闭包坏处 1.常驻内存，增加内存使用量 2.使用不当造成内存泄漏（一块被分配的内存既不能使用，又不能回收）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js变量提升]]></title>
    <url>%2F2019%2F04%2F02%2F20190402-1%2F</url>
    <content type="text"><![CDATA[变量进入作用域方式1.语言内置：所有的作用域都有 this 和 arguments2.形式参数：函数的形式参数会作为函数作用域的一部分3.函数声明: function a(){}4.变量声明：var a; 变量提升函数及变量的声明都将被提升到函数的最顶部 函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。1234567891011121314151617181920function test1() &#123; a = 5; console.log(a); console.log(window.a); var a = 10; console.log(a);&#125;test1();log依次为5，undefined，10；实际执行顺序function test1() &#123; var a; a = 5; console.log(a); console.log(window.a); var a = 10; console.log(a);&#125; 因为a = 5,在test1内执行，所以window.a为undefined 如果直接在window下执行12345a = 5;console.log(a);console.log(window.a);var a = 10;console.log(a); 结果，5,5,10;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5调起摄像头拍照]]></title>
    <url>%2F2019%2F03%2F29%2F20190329-1%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// html部分&lt;video id="video" width="480" height="320" controls&gt;&lt;/video&gt;&lt;div&gt; &lt;button id="capture"&gt;拍照&lt;/button&gt;&lt;/div&gt;&lt;canvas id="canvas" width="480" height="320"&gt;&lt;/canvas&gt;let video = document.getElementById('video');let canvas = document.getElementById('canvas');let context = canvas.getContext('2d');//访问用户媒体设备的兼容方法function getUserMedia(constraints, success, error) &#123; if (navigator.mediaDevices.getUserMedia) &#123; //最新的标准API navigator.mediaDevices .getUserMedia(constraints) .then(success) .catch(error); &#125; else if (navigator.webkitGetUserMedia) &#123; //webkit核心浏览器 navigator.webkitGetUserMedia(constraints, success, error); &#125; else if (navigator.mozGetUserMedia) &#123; //firfox浏览器 navigator.mozGetUserMedia(constraints, success, error); &#125; else if (navigator.getUserMedia) &#123; //旧版API navigator.getUserMedia(constraints, success, error); &#125;&#125;function success(stream) &#123; //兼容webkit核心浏览器 let CompatibleURL = window.URL || window.webkitURL; //将视频流设置为video元素的源 console.log(stream); //video.src = CompatibleURL.createObjectURL(stream); video.srcObject = stream; video.play();&#125;function error(error) &#123; console.log(`访问用户媒体设备失败$&#123;error.name&#125;, $&#123;error.message&#125;`);&#125;if ( navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123; //调用用户媒体设备, 访问摄像头 getUserMedia(&#123;video: &#123;width: 480, height: 320&#125;&#125;, success, error);&#125; else &#123; alert("不支持访问用户媒体");&#125;// 点击拍照document.getElementById('capture').addEventListener('click', function () &#123; context.drawImage(video, 0, 0, 480, 320); &#125;)]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64与file格式图片转换]]></title>
    <url>%2F2019%2F03%2F26%2F20190326-1%2F</url>
    <content type="text"><![CDATA[base64转file123456789101112131415function dataURLtoFile(dataurl, filename) &#123; //将base64转换为文件 var arr = dataurl.split(","), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123; type: mime &#125;);&#125;var file = dataURLtoFile(imgUrl, "img"); file转base64base64转blob,blob转file1234567891011121314151617181920function dataURLtoBlob (dataurl) &#123; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123; type: mime &#125;);&#125;; //将blob转换为filefunction blobToFile:(theBlob, fileName)&#123; theBlob.lastModifiedDate = new Date(); theBlob.name = fileName; return theBlob;&#125;;//调用var blob = dataURLtoBlob(base64Data);var file = blobToFile(blob, imgName);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[export 和 module export]]></title>
    <url>%2F2019%2F03%2F15%2F20190315-6%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async await]]></title>
    <url>%2F2019%2F03%2F15%2F20190315-5%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js作用域详解]]></title>
    <url>%2F2019%2F03%2F15%2F20190315-4%2F</url>
    <content type="text"><![CDATA[变量作用域js中全局作用域比较简单，在代码任何地方都有定义。函数的参数和局部变量只在函数内有定义。局部变量优先级高于同名全局变量，当局部变量和全局变量同名，局部变量覆盖全局变量 函数作用域在变量声明的代码段之外没有定义，成为块级作用域。js中使用的是函数作用域（变量在声明他们的函数体以及这个函数体嵌套的任何函数体都是有定义的） 作用域链js中函数也是对象，一切都是对象。函数拥有可以通过代码访问的属性和一系列仅供js引擎访问的内部属性。其中一个内部属性是[[scope]]。该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问函数被创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。 执行函数时，会创建一个称为‘运行期上下文’的内部对象，运行期上下文定义了函数执行的环境。每个运行期上下文都有自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链接初始化为当前运行函数的[[scope]]所包含的对象。 这些值，按照出现在函数中的顺序被复制到运行期上下文的作用域中。它们共同组成一个新的对象，叫做‘活动对象’。该对象包含了函数的所有的局部变量，命名参数、参数集合以及this，然后此对象被推入作用域链的前端，当运行期上下文被销毁时，活动对象也随之销毁 函数解析和执行过程a(); 解析：1.代码进入浏览器，因为会有标识符解析，所以在这之前，js解释器需要扫面全局，初始化全局作用域。2.a变量进入全局作用域，a仍是undefined，当解释器自上而下解释到这段代码时,创建一个匿名函数3.将全局作用域压进函数对象的内部属性 所引用的作用域链里[[scope]]4.将匿名对象赋值给a 执行1.创建内部对象，称为该对象的‘执行期上下文’。定义了一个函数的执行环境，函数每次执行都会创建独一无二的执行期上下文，每个执行期上下文都有自己的作用域链，用来解析标识符。2.当执行期上下文创建时，它的作用域链会被初始化为当前执行的函数对象里的[[scope]]属性中包含的对象3.scope中的值，按照它们原有的顺序被复制到执行期上下文的作用链里4.解析器创建一个称为‘活动对象’的内部对象，活动对象包含当前执行函数里所有的局部变量，命名参数，参数合计以及this。5.活动对象被推入执行期上下文里中作用域链的前端。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 三栏布局以及延伸]]></title>
    <url>%2F2019%2F03%2F15%2F20190315-3%2F</url>
    <content type="text"></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 边距重叠 与 BFC]]></title>
    <url>%2F2019%2F03%2F15%2F20190315-2%2F</url>
    <content type="text"></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call和apply]]></title>
    <url>%2F2019%2F03%2F15%2F20190315-1%2F</url>
    <content type="text"><![CDATA[概念每个Function对象，都带有一个apply()和call()方法 12345// 语法function.apply(thisObj[, argArray])function.call(thisObj[, arg1[, arg2[, [,...argN]]]]); apply() :调用一个对象的一个方法，用另一个对象替换当前对象。例如，B.apply(A, arguments); 即A对象应用B对象的方法 call() : 调用一个对象的一个方法，用另一个对象替换当前对象。 例如，B.call(A, arg1, arg2); 即A对象调用B对象的方法 共同之处：都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为有thisObj指定的新对象。 不同之处： apply：最多只能有两个参数 新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeRrror。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被作为thisObj，并且无法传递任何参数 call： 可以接受多个参数，第一个参数和apply一样，后面是一串参数列表；主要用在js对象各方法互相调用的时候，使当前this指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么Golbal对象被用作thisObj。 实际上，apply和call功能一样，只是传入的参数列表形式不同。 实现继承普通继承12345678910111213141516function Animal(name)&#123; this.name = name; this.showName = function()&#123; alert(this.name); &#125; &#125;function Cat(name)&#123; Animal.apply(this,[name]); &#125;var cat = new Cat("咕咕");cat.showName();/*call的用法*/Animal.call(this,name); 多重继承1234567891011121314151617181920function a()&#123; this.showSub = function(a,b)&#123; alert(a - b); &#125; &#125;function b()&#123; this.showAdd = function(a,b)&#123; alert(a + b); &#125; &#125;function c()&#123; a.apply(this); b.apply(this); &#125;var c = new c();c.showSub(3,1); //2c.showAdd(3,1); //4 apply妙用Math.max/Math.min得到数组中最大/小的一项123var arr = [1,2,3,4,5,6,7];var max = Math.max.apply(null, arr);var min = Math.min.apply(null, arr); Array.prototype.push 可以实现两个数组的合并1234var arr1 = [1,2,3,4,5];var arr2 = [6,7,8,9,0];var arr3 = Array.prototype.push.apply(arr1, arr2);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[object方法]]></title>
    <url>%2F2019%2F02%2F28%2F20190228-1%2F</url>
    <content type="text"><![CDATA[1. Object.assign(target,source1,source2,…); 合并对象将源对象的所有可枚举的属性合并到目标对象上。只拷贝源对象的自身属性，不拷贝继承的属性。 浅拷贝。如果拷贝的某个属性是对象，那么拷贝到的是这个对象的引用。 只进行值的复制，如果复制的值是个取值函数，那么求值后复制。 可以处理数组，但会把数组看做对象 同值属性被覆盖 123456789const target = &#123; x:0&#125;const source = &#123; x:1, y:0&#125;Object.assign(target,source);//target &#123;x:1,y:0&#125; 2.Object.create(prototype,[propertiesObject]); 使用指定的原型对象及其属性去创建一个新的对象123456789101112var a =&#123; x:0, y:0&#125;;var b = Object.create(a,&#123; z:&#123; writable:true, //是否可以采用 数据运算符 进行赋值 configurable:true, //是否可以修改、删除 value: "newAdd" //值 &#125;&#125;);输出： b = &#123;z:'newAdd'&#125; 3.Object.defineProperties(obj,props); 直接在一个对象上定义新的属性或修改现有属性，并返回该对象 （批量）12345678910111213var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'property1': &#123; value: true, writable: true &#125;, 'property2': &#123; value: 'Hello', writable: false &#125; // etc. etc.&#125;);console.log(obj) // &#123;property1: true, property2: "Hello"&#125; 4.Object.defineProperty(obj,prop,descriptor); 在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。（单个）obj：必需。目标对象prop：必需。需定义或修改的属性的名字descriptor：必需。目标属性所拥有的特性123456789101112var Object = &#123;&#125;;Object.defineProperty(Object, 'is', &#123; value: 2, configurable: true, // 是否可以删除或者再次修改属性 enumerable: false, //是否可以被枚举 writable: true // 是否可以被重写&#125;); // Object = &#123;is:2&#125;// 注意不能同时设置(writable，value) 和 get，set方法，否则浏览器会报错 // 如果不设置属性特性。configurable、enumerable、writable 都默认为false//Invalid property descriptor. Cannot both specify accessors and a value or writable attribute getter/setter当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。 getter 是一种获得属性值的方法setter是一种设置属性值的方法。 可在获取值和设置值的时候触发 12345678910111213141516171819var obj = &#123;&#125;;var initValue = 'hello';Object.defineProperty(obj,"newKey",&#123; get:function ()&#123; //当获取值的时候触发的函数 return initValue; &#125;, set:function (value)&#123; //当设置值的时候触发的函数,设置的新值通过参数value拿到 initValue = value; &#125;&#125;);//获取值console.log( obj.newKey ); //hello//设置值obj.newKey = 'change value';console.log( obj.newKey ); //change value 5.Object.keys(); 返回一个由一个给定对象的自身可枚举属性组成的数组,顺序与for…in获取的相同，但是for..i还会魅族其原型链的属性1234let arr = ["a", "b", "c"];console.log(Object.keys(arr));// ['0', '1', '2']/* Object 对象 */let obj = &#123; foo: "bar", baz: 42 &#125;, keys = Object.keys(obj);console.log(keys);// ["foo","baz"] 6.Object.values(); 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。Object.values会过滤属性名为 Symbol 值的属性。1234var an_obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.values(an_obj)); // ['b', 'c', 'a']var obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.values(obj)); // ['a', 'b', 'c'] 7.Object.entries(); 返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。12345const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ] const simuArray = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.entries(simuArray)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ] 8.hasOwnProperty()判断对象自身属性中是否具有指定的属性。 obj.hasOwnProperty(‘name’) 9.Object.getOwnPropertyDescriptor(obj,prop);返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）.如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。1234var arr = ['name','age'] ;arr.forEach(val =&gt; console.log(Object.getOwnPropertyDescriptor(obj,val)))// &#123;value: "js", writable: true, enumerable: true, configurable: true&#125;// undefined 10. Object.getOwnPropertyDescriptors(obj) 获取一个对象的所有自身属性的描述符。12345var obj = &#123; name : 'js', age : 20&#125;console.log(Object.getOwnPropertyDescriptors(obj)) 11. Object.getOwnPropertyNames(); 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。1234567var obj = &#123; 0: "a", 1: "b", 2: "c"&#125;;Object.defineProperty(obj,'z',&#123; enumerable : false&#125;)console.log(Object.getOwnPropertyNames(obj)) // ["x", "y", "z"] 包含不可枚举属性 。console.log(Object.keys(obj)) // ["x", "y"] 只包含可枚举属性 。 12 Object.getOwnPropertySymbols();返回一个给定对象自身的所有 Symbol 属性的数组。13 isPrototypeOf(); 判断一个对象是否存在一另一个对象的原型链上14 Object.getOwnPropertySymbols(); 返回一个给定对象自身的所有 Symbol 属性的数组。15 Object.is(); 判断两个对象是否相同如果下列任何一项成立，则返回true两个值都是 undefined两个值都是 null两个值都是 true 或者都是 false两个值是由相同个数的字符按照相同的顺序组成的字符串两个值指向同一个对象两个值都是数字并且都是正零 +0都是负零 -0都是 NaN都是除零和 NaN 外的其它同一个数字 123456789101112131415Object.is('foo', 'foo'); // trueObject.is(window, window); // true Object.is('foo', 'bar'); // falseObject.is([], []); // false var test = &#123; a: 1 &#125;;Object.is(test, test); // true Object.is(null, null); // true // 特例Object.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true 16 Object.freeze() 冻结一个对象。被冻结的对象 是永远不变的，返回被冻结的对象17 Object.isFrozen() 判断一个对象是否被冻结 .18 Object.preventExtensions() 对象不能再添加新的属性。可修改，删除现有属性1234567891011121314var obj = &#123; name :'lilei', age : 30 , sex : 'male'&#125; obj = Object.preventExtensions(obj);console.log(obj); // &#123;name: "lilei", age: 30, sex: "male"&#125;obj.name = 'haha';console.log(obj) // &#123;name: "haha", age: 30, sex: "male"&#125;delete obj.sex ;console.log(obj); // &#123;name: "haha", age: 30&#125;obj.address = 'china';console.log(obj) // &#123;name: "haha", age: 30&#125; 19 Object.isExtensible() 判断对象是否是可扩展的，Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）20 Object.seal() 让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常. 不会影响从原型链上继承的属性。但 proto ( ) 属性的值也会不能修改。123456789101112131415161718192021222324252627282930313233343536var obj = &#123; prop: function () &#123;&#125;, foo: "bar" &#125;; // 可以添加新的属性,已有属性的值可以修改,可以删除obj.foo = "baz";obj.lumpy = "woof";delete obj.prop; var o = Object.seal(obj); assert(o === obj);assert(Object.isSealed(obj) === true); // 仍然可以修改密封对象上的属性的值.obj.foo = "quux"; // 但你不能把一个数据属性重定义成访问器属性.Object.defineProperty(obj, "foo", &#123; get: function() &#123; return "g"; &#125; &#125;); // 抛出TypeError异常 // 现在,任何属性值以外的修改操作都会失败.obj.quaxxor = "the friendly duck"; // 静默失败,新属性没有成功添加delete obj.foo; // 静默失败,属性没有删除成功 // ...在严格模式中,会抛出TypeError异常function fail() &#123; "use strict"; delete obj.foo; // 抛出TypeError异常 obj.sparky = "arf"; // 抛出TypeError异常&#125;fail(); // 使用Object.defineProperty方法同样会抛出异常Object.defineProperty(obj, "ohai", &#123; value: 17 &#125;); // 抛出TypeError异常Object.defineProperty(obj, "foo", &#123; value: "eit" &#125;); // 成功将原有值改变 21.Object.isSealed() 判断一个对象是否密闭Object状态:1.冻结。永远不会变2.密闭。 a:不可添加新属性 b:已有属性变的不可删除 c:数据的属性不能被重新定义为转换器属性 d:属性值仍然可以修改 e:尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常. 不会影响从原型链上继承的属性 f:proto ( ) 属性的值也会不能修改3.不可扩展：对象不能再添加新的属性。可修改，删除现有属性]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue首屏加载时间过长优化]]></title>
    <url>%2F2019%2F02%2F21%2F20190221-1%2F</url>
    <content type="text"><![CDATA[主要思路：减小首屏加载的js文件体积 1.减少不必要的引用1.看package.json;2.查看打包分析 安装 webpack-bundle-analyzer vue.config.js配置 chainWebpack: (config) =&gt; { //打包分析 config.plugin(‘webpack-bundle-analyzer’) .use(BundleAnalyzerPlugin) .init(Plugin =&gt; new Plugin()); }, run build –report 2.路由懒加载，组件懒加载3.引用转为cdn]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex兼容]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-12%2F</url>
    <content type="text"><![CDATA[###旧版本dispaly: box;，过渡版本dispaly: flex box;，以及现在的标准版本display: flex Android2.3 开始就支持旧版本 display:-webkit-box;4.4 开始支持标准版本 display: flex; IOS6.1 开始支持旧版本 display:-webkit-box;7.1 开始支持标准版本display: flex; PCie10开始支持，但是IE10的是-ms形式的。 ### ###写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.flex &#123; display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */&#125;.flex-1 &#123; -webkit-flex: 1; /* Chrome */ -ms-flex: 1; /* IE 10 */ flex: 1; /* NEW, Spec - Opera 12.1, Firefox 20+ */ -webkit-box-flex: 1; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex: 1; /* OLD - Firefox 19- */&#125;.flex-v &#123; -webkit-box-orient: vertical; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column;&#125;.flex-align-center &#123; -webkit-box-align: center; -webkit-align-items: center; -ms-flex-align: center; align-items: center;&#125;.flex-pack-center &#123; -webkit-box-pack: center; -webkit-justify-content: center; -ms-flex-pack: center; justify-content: center;&#125;.flex-pack-justify &#123; -webkit-box-pack: justify; -webkit-justify-content: space-between; -ms-flex-pack: justify; justify-content: space-between;&#125;.flex-pack-around &#123; -webkit-box-pack: center; -webkit-justify-content: space-around; -ms-flex-pack: center; justify-content: space-around;&#125; 兼容性：ios 4+、android 2.3+、winphone8+ ###]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现面向对象]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-11%2F</url>
    <content type="text"><![CDATA[###面向对象：将抽象模型实例化为对象，属性和方法都通过操作对象来获取和实现。123456function Cat(color,name)&#123; this.color:color, this.name:name&#125;var cat1 = new Cat('黄色','大毛'); ###]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css单位]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-10%2F</url>
    <content type="text"><![CDATA[###%:百分比cm：厘米mm：毫米px:像素in：英寸 rgb(x,x,x) RGB 值 (比如 rgb(255,0,0))rgb(x%, x%, x%) RGB 百分比值 (比如 rgb(100%,0%,0%)) #rrggbb 十六进制数 (比如 #ff0000) 新属性vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）vh：视窗高度的百分比vmin：当前 vw 和 vh 中较小的一个值vmax：当前 vw 和 vh 中较大的一个值 做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。 Android：自 4.4 版起就完美支持（2013年12月）iOS：自 iOS8 版起就完美支持（2014年9月） ###]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 动画]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-9%2F</url>
    <content type="text"><![CDATA[补间动画指控制最开始的状态和最末的状态的动画，中间的状态由浏览器自动帮我们计算生成。 逐帧动画时间轴上定义关键帧，通过连续播放形成动画 实现属性css animationcss transiton]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-8%2F</url>
    <content type="text"><![CDATA[### js 实现异步操作的一种方式 三种状态 等待（pending）、已完成（fulfilled）、已拒绝（rejected） Promise 的构造函数接收一个函数作为参数，该函数接受两个额外的函数，resolve 和 reject，这两个函数分别代表将当前 Promise 置为 fulfilled(解决)和 rejected(拒绝)两个状态。Promise 正是通过这两个状态来控制异步操作的结果 resolve()内部的参数会传递给 then(); reject 方法参数传给 catch(); 当 Promise 中的函数执行 resolve 方法后，由之前的 pending –&gt; resolved 基础例子： 12345678910111213141516171819202122232425262728293031323334353637var promise = new Promise(function (resolve, reject) &#123; if (执行某些操作成功了) &#123; resolve(&#123; name:'resolve' &#125;); &#125;else &#123; //执行失败 reject(&#123; name:'err' &#125;); &#125;&#125;)同时监听成功和错误promise.then(function(contents)&#123; //成功 console.log(contents)&#125;,function(err)&#123; //拒绝 console.error(err.message)&#125;)只监听成功promise.then(function(contents)&#123; //成功 console.log(contents)&#125;)只监听错误promise.then(null,function(error)&#123; //拒绝 console.error(err)&#125;)promise的catch方法，相当于只给其传入拒绝处理程序的then()方法。promise.catch(function(err)&#123; console.error(err.message)&#125;) 多个函数实战12345678910111213141516171819function a() &#123; return new Promise(function(resolve, reject) &#123; console.log("a"); &#125;);&#125;function b() &#123; return new Promise(function(resolve, reject) &#123; console.log("b"); &#125;);&#125;function c() &#123; return new Promise(function(resolve, reject) &#123; console.log("c"); &#125;);&#125;a() .then(b()) .then(c()); Promise.then()回调异步性1234567891011var p1 = new Promise(function(resolve, reject) &#123; resolve("success");&#125;);p1.then(function(val) &#123; console.log(val);&#125;);console.log("which one is called first ?");success后执行; .then()语法：Promise.prototype.then(onFulfilled, onRejected); 对 promise添加onFulfilled 和 onRejected 回调，并返回一个新的Promise实例，且返回值将作为参数传入这个心的Promise的resolve函数 因此，可以使用链式写法。后一个回调函数，会等待前一个promise对象的状态发生变化，才会被调用 1234567891011121314151617var promise = new Promise(function (resolve, reject) &#123; if (执行某些操作成功了) &#123; resolve(&#123; name:'resolve' &#125;); &#125;else &#123; //执行失败 reject(&#123; name:'err' &#125;); &#125;&#125;)promise.then(function(res)&#123; //resolve时执行&#125;,function(err)&#123; //reject时执行&#125;) .catch().then(undefinedn,onRejected)的别名，用于指定发生错误时的回调函数 123456789101112promise.then(function(data) &#123; console.log('success');&#125;).catch(function(error) &#123; console.log('error', error);&#125;);/*******等同于*******/promise.then(function(data) &#123; console.log('success');&#125;).then(undefined, function(error) &#123; console.log('error', error);&#125;); .all()var p = Promise.all([p1,p2,p3]); 该方法接受一个数组作参数，数组中对象均为promise实例(如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。p 的状态由这三个promise实例决定。 p1,p2,p3 也是同时执行，不是顺序执行 当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数 123456789101112131415161718var p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, "one"); &#125;); var p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 2000, "two"); &#125;);var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, "third");&#125;);Promise.all([p1, p2, p3]).then(function (value) &#123; console.log('resolve', value);&#125;, function (error) &#123; console.log('reject', error); // =&gt; reject three&#125;);//约 3s 后["first", "second", "third"] 当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数 1234567891011121314151617var p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, "one"); &#125;); var p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 2000, "two"); &#125;);var p3 = new Promise((resolve, reject) =&gt; &#123; reject("three");&#125;);Promise.all([p1, p2, p3]).then(function (value) &#123; console.log('resolve', value);&#125;, function (error) &#123; console.log('reject', error); // =&gt; reject three&#125;);reject three .race()该方法同样将多个Promise实例，包装成一个新的Promise实例 var p = Promise.race([p1,p2,p3]); p1,p2,p3谁先有返回，p就返回它的返回 Promise.race 接收一个数组作参数，当P1,P2,P3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就发生改变，并将第一个改变状态的promise的返回值，传给p的回调函数 123456789101112131415var p1 = new Promise(function(resolve, reject) &#123; setTimeout(reject, 500, "one"); &#125;);var p2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, "two"); &#125;);Promise.race([p1, p2]).then(function(value) &#123; console.log('resolve', value); &#125;, function(error) &#123; //not called console.log('reject', error); &#125;);-------output-------resolve two 当第一个promise对象变为resolve后，并不会取消其他promise对象的执行 reslove();12345Promise.resolve('success');等同于new Promise(function(resolve)&#123; resolve('success');&#125;) 这个方法会让这个Promise对象立即进入resolve状态，并将结果success传递给then执行的onfulfilled回调函数 12345Promise.resolve('success').then(function(value)&#123; console.log(value)&#125;)输出 Success .reject()12345Promise.reject(new Error('error'));等同于new Promise(function(resolve,reject)&#123; reject(new Error('error'));&#125;) 让Promise对象立即进入rejected状态，并将错误对象传递到执行的onRejected回调函数 注意点：1. reject 和catch 的区别promise.then(onfulfilled,onrejected)在onFulfilled中发生异常的话，在onrejected中是捕获不到这个异常的 promise.then(onFulfilled).catch(onRejected).then中产生的异常可以在.catch中捕获 一般情况下，使用catch。catch也可以用then表示.catch === .then(null, onRejected) 2.如果then中抛出了错误，而没有catch，会一直保持rejected状态，直到catch了错误1234567891011121314151617181920212223function taskA() &#123; console.log(x); console.log("Task A");&#125;function taskB() &#123; console.log("Task B");&#125;function onRejected(error) &#123; console.log("Catch Error: A or B", error);&#125;function finalTask() &#123; console.log("Final Task");&#125;var promise = Promise.resolve();promise .then(taskA) .then(taskB) .catch(onRejected) .then(finalTask); -------output-------Catch Error: A or B,ReferenceError: x is not definedFinal Task 3.每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据4.promise的状态变为resolve活reject ，就凝固了，不会再改变]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端缓存机制]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js安全]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[css BFC]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-4%2F</url>
    <content type="text"><![CDATA[1.无模块化12&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="jquery_scroller.js"&gt;&lt;/script&gt; 缺点：1.污染全局作用域 2.依赖关系不明显 2. commonJS规范最初应用于服务端前端webpack也对CommonJS原生支持 每一个文件就是一个模块，内部定义的变量属于这个模块，不会对外暴露，不会污染全局。 核心思想：通过require同步加载所要依赖的其他模块，通过exports 或者module.exports 来导出需要暴露的接口 module代表这个模块，exports代表要暴露的接口，默认顶部有一句代码 exports = module.exports 所以不能直接给exports赋值， 如 number/function等 123456789101112// a.jsvar x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX;// 引用var a = require('./a.js');console.log(a.x); // 5console.log(a.addX(1)); // 6 优点：commonJS率先在服务端完成模块化，解决了依赖全局变量污染的问题缺点：由于commonJS是同步加载模块，在浏览器端不适用。 3. AMD规范AMD规范则是非同步加载模块，允许指定回调函数.AMD规范的实现：require.jsAMD标准定义了两个API121.require([module],callback)2.define(id,[depends],callback) 即通过define定义模块，require加载模块。且require支持commonJS的模块导出方式、 定义alert模块：123456789101112define(function () &#123; var alertName = function (str) &#123; alert("I am " + str); &#125; var alertAge = function (num) &#123; alert("I am " + num + " years old"); &#125; return &#123; alertName: alertName, alertAge: alertAge &#125;;&#125;); 引入模块1234require(['alert'], function (alert) &#123; alert.alertName('JohnZhu'); alert.alertAge(21);&#125;); 在使用requireJS时候，必须提前加载所有的依赖，然后才能使用 优点:适合在浏览器端异步加载模块，可以并行加载多个模块缺点：提高了开发成本，并且不能按需加载，必须提前加载完所有依赖 4.CMD规范CMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：123456define(function(require, exports, module) &#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ...&#125;) 优点： 浏览器端模块加载，按需加载，依赖就近缺点： 依赖SPM打包，模块的加载逻辑偏重 AMD和CMD区别： 前者对依赖提前执行，后者延迟执行。 前者推崇依赖前置，后者推崇依赖就近，即在需要时候某个模块在require 1234567891011121314151617// AMDdefine(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;);// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;); 5.ES6模块化之前的模块化都是社区自己实现的，只是得到大家的认可和广泛使用，而ES6是官方推出的真正规范的模块化方案。使用import引入模块，通过export导出模块。目前ES6在浏览器支持性不高，通过babel将import编译为require 123456789101112import store from '../store/index'import &#123;mapState, mapMutations, mapActions&#125; from 'vuex'import axios from '../assets/js/request'import util from '../utils/js/util.js'export default &#123; created () &#123; this.getClassify(); this.RESET_VALUE(); console.log('created' ,new Date().getTime());&#125;`]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue双向绑定原理]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-2%2F</url>
    <content type="text"></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eventLoop机制]]></title>
    <url>%2F2019%2F01%2F30%2F20190130-1%2F</url>
    <content type="text"><![CDATA[1.js为单线程假设js有两个线程，一个在某个dom添加内容，另一个在这个dom删除内容，浏览器应该以哪个线程为准？这就意味着，单线程为js核心标准，将一直沿用下去。 web worker : 号称让js成为一门多线程语言所有新线程受主线程的控制，不能独立执行。实际上属于主线程的子线程。子线程没有执行I/O操作的权限，只能为主线程分担计算等任务，严格说，这些线程没有完整功能，并非改变了js的单线程本质。 2.事件循环一直在查找新的事件执行，一次执行的循环成为tick，循环里执行的代码称为task 任务分同步和异步js执行时将不同变量存在内存的不同位置：堆（heap）和栈（stack）中区分。堆中一般存变量，stack一般存函数和方法。stack叫做执行栈，方法会依次在这里执行。执行栈事件先进先出，任务队列先进先出。web apis代表异步事件，callback queue事件队列 执行栈执行主线程任务，当有操作dom，ajax交互，定时器 等异步操作时候，任务会移入到callback queue任务队列当主线程执行完毕后，读取callbakc quene队列中的函数，进入主线程执行。不断重复，就是常说的事件循环（eventloop） 3.macro task和 micro task不同的异步任务会分为两类：微任务（micro）和宏任务（macro） 在一个事件循环中，异步事件返回结果后被放到对应的宏任务队列或者微任务队列中去。 宏任务-&gt;这个宏任务中的微任务-&gt;下一个宏任务-&gt;下一个宏任务添加的微任务 当执行栈为空时，主线程会首先查看微任务中的事件，如果微任务不是空执行微任务。如果没有任务，在宏任务中取出最前面的一个事件，把对应的回调加入当前执行栈……… 如此反复，进入循环 macro-task(宏任务) 整体代码 settimeout setinterval setlmmediate 主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval micro-task(微任务) process.nextTick &gt; Promise &gt; MutationObserver]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meta 标签内属性详解]]></title>
    <url>%2F2018%2F12%2F06%2F20181206-1%2F</url>
    <content type="text"><![CDATA[1&lt;meta name="参数" content="具体的描述"&gt; meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。 name 属性1.keywords用于告诉搜索引擎，你网页的关键字。举例： 2.description用于告诉搜索引擎，你网站的主要内容。举例： 3. viewport(移动端的窗口) width = device-width宽度等于当前设备的宽度 initial-scale = 1.0初始缩放比例，默认为1（倍） minimum-scale = 1.0/maximum-scale = 1.0最小/大缩放比例1（倍） user-scalable = no是否允许用户缩放页面（yes/no） D.robotrobots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。content的参数有all,none,index,noindex,follow,nofollow。默认是all。举例： 1.none : 搜索引擎将忽略此网页，等价于noindex，nofollow。2.noindex : 搜索引擎不索引此网页。3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。5.index : 搜索引擎索引此网页。6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。E.author用于标注网页作者 F.generator(网页制作软件) G.copyright(版权) H.revisit-after(重访)如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问 I.rendererrenderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说360浏览器。 //默认webkit内核 //默认IE兼容模式 //默认IE标准模式 http-equiv属性http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 A.Expires(期限)说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输 注意：必须使用GMT的时间格式。 B.Pragma(cache模式)说明：禁止浏览器从本地计算机的缓存中访问页面内容。 注意：这样设定，访问者将无法脱机浏览。 C.Refresh(刷新)说明：自动刷新并指向新页面。1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2; URL = http://www.baidu.com&quot;&gt; (注意后面的引号，分别在秒数的前面和网址的后面) 注意：其中的2是指停留2秒钟后自动刷新到URL网址 D.Set-Cookie(cookie设定)说明：如果网页过期，那么存盘的cookie将被删除。用法：注意：必须使用GMT的时间格式 E.Window-target(显示窗口的设定)说明：强制页面在当前窗口以独立页面显示。用法：注意：用来防止别人在框架里调用自己的页面 F.content-Type(显示字符集的设定)说明：设定页面使用的字符集。用法：注意：HTML5中使用 来设定 meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文； meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文； meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文； meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文； meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文； meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码； G.content-Language（显示语言的设定）用法： H.Cache-Control指定请求和响应遵循的缓存机制。Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下 Public指示响应可被任何缓存区缓存 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效 no-cache指示请求或响应消息不能缓存 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F28%2F20181128-1%2F</url>
    <content type="text"><![CDATA[&lt;&lt;&lt;&lt;&lt;&lt;&lt; .minetitle: html5新特性date: 2018-11-28 17:03:48 categories: html背景html5新特性盘点，面试常见 内容一.更多的语义标签语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。 &lt;section&gt;&lt;/section&gt; 定义文档中的主体部分的节、段 &lt;article&gt;&lt;/article&gt; 一个特殊的section标签，比section有更明确的语义。定义来自外部的一个独立的、完整的内容块，例如什么论坛的文章，博客的文本 &lt;aside&gt;&lt;/aside&gt; 页面中非正文的内容，独立于其他模块。例如广告、成组的链接、侧边栏 &lt;header&gt;&lt;/header&gt; 定义文档、页面的页眉。通常是一些引导和导航信息，不局限于整个页面头部，也可以用在内容里 &lt;footer&gt;&lt;/footer&gt; 定义了文档、页面的页脚，和header类似 &lt;nav&gt;&lt;/nav&gt; 定义了一个链接组组成的导航部分，其中的链接可以链接到其他网页或者当前页面的其他部分 &lt;hgroup&gt;&lt;/hgroup&gt; 用于对网页或区段(section)的标题元素(h1~h6) &lt;details&gt;&lt;/details&gt; 定义元素的细节，用户可以点击查看或者隐藏 &lt;summary&gt;&lt;/summary&gt; （译：摘要，一览） 和details连用，用来包含details的标题 &lt;canvas&gt;&lt;/canvas&gt; 画布 &lt;video&gt;&lt;/video&gt; &lt;audio&gt;&lt;/audio&gt; &lt;embed&gt;&lt;/embed&gt; （译：嵌入）定义嵌入网页的内容。比如插件。 &lt;source&gt;&lt;/source&gt; 该标签为媒介元素(比如video、audio)定义媒介元素。 &lt;datalist id=&#39;dl&#39;&gt;&lt;/datalist&gt; 定义可选数据的列表，与input配合使用( &lt;input list=&#39;dl&#39;&gt; )可制作输入值的下拉列表。 &lt;mark&gt;&lt;/mark&gt; 在视觉上向用户展现出那些想要突出的文字。比如搜索结果中向用户高亮显示搜索关键词 &lt;progress&gt;&lt;/progress&gt; 进度条，运行中的进度。 &lt;output&gt;&lt;/output&gt; 定义不同类型的输出，样式与span相同 &lt;keygen&gt;&lt;/keygen&gt; 定义加密内容 &lt;command&gt;&lt;/command&gt; 定义命令行为 &lt;figure&gt;&lt;/figure&gt; 独立于文章的内容，如果删除，对内容无影响 &lt;time&gt;&lt;/time&gt; 定义时间和日期 二.本地存储（localStorage和sessionStorage） localStorage存储大小：5M(cookie为4K)兼容：ie8+ /Chrome 5+特点：永久存储，不会被爬虫爬到，值类型限定为string，只在本地生效读:localStorage.getItem(‘name’)localStorage.namelocalStorage.key(‘name’) //通过key值获取删：localStorage.removeItem(‘name’)检测是否存在某个变量：localStorage.hasOwnProperty(‘name’) //hasOwnProperty为对象的方法，可以用来检测一个对象是否含有特定的自身属性 sessionStorage与localStorage不同之处：1.临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据2.同源策略限制。若想在不同页面之间对同一个sessionStorage进行操作，这些页面必须在同一协议、同一主机名和同一端口下。(IE 8和9存储数据仅基于同一主机名，忽略协议（HTTP和HTTPS）和端口号的要求)3.sessionStorage操作限制在单个标签页中，在此标签页进行同源页面访问都可以共享sessionStorage数据 三.离线web应用页面缓存指的还是有网络状态下，而离线web应用指的是在没有网络状态可以运行应用 检测是否支持： =======title: ‘html5新特性’date: 2018-11-28 17:03:48 categories: html背景html5新特性盘点，面试常见 内容一.更多的语义标签语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。 &lt;section&gt;&lt;/section&gt; 定义文档中的主体部分的节、段 &lt;article&gt;&lt;/article&gt; 一个特殊的section标签，比section有更明确的语义。定义来自外部的一个独立的、完整的内容块，例如什么论坛的文章，博客的文本 &lt;aside&gt;&lt;/aside&gt; 页面中非正文的内容，独立于其他模块。例如广告、成组的链接、侧边栏 &lt;header&gt;&lt;/header&gt; 定义文档、页面的页眉。通常是一些引导和导航信息，不局限于整个页面头部，也可以用在内容里 &lt;footer&gt;&lt;/footer&gt; 定义了文档、页面的页脚，和header类似 &lt;nav&gt;&lt;/nav&gt; 定义了一个链接组组成的导航部分，其中的链接可以链接到其他网页或者当前页面的其他部分 &lt;hgroup&gt;&lt;/hgroup&gt; 用于对网页或区段(section)的标题元素(h1~h6) &lt;details&gt;&lt;/details&gt; 定义元素的细节，用户可以点击查看或者隐藏 &lt;summary&gt;&lt;/summary&gt; （译：摘要，一览） 和details连用，用来包含details的标题 &lt;canvas&gt;&lt;/canvas&gt; 画布 &lt;video&gt;&lt;/video&gt; &lt;audio&gt;&lt;/audio&gt; &lt;embed&gt;&lt;/embed&gt; （译：嵌入）定义嵌入网页的内容。比如插件。 &lt;source&gt;&lt;/source&gt; 该标签为媒介元素(比如video、audio)定义媒介元素。 &lt;datalist id=&#39;dl&#39;&gt;&lt;/datalist&gt; 定义可选数据的列表，与input配合使用( &lt;input list=&#39;dl&#39;&gt; )可制作输入值的下拉列表。 &lt;mark&gt;&lt;/mark&gt; 在视觉上向用户展现出那些想要突出的文字。比如搜索结果中向用户高亮显示搜索关键词 &lt;progress&gt;&lt;/progress&gt; 进度条，运行中的进度。 &lt;output&gt;&lt;/output&gt; 定义不同类型的输出，样式与span相同 &lt;keygen&gt;&lt;/keygen&gt; 定义加密内容 &lt;command&gt;&lt;/command&gt; 定义命令行为 &lt;figure&gt;&lt;/figure&gt; 独立于文章的内容，如果删除，对内容无影响 &lt;time&gt;&lt;/time&gt; 定义时间和日期 二.本地存储（localStorage和sessionStorage） localStorage存储大小：5M(cookie为4K)兼容：ie8+ /Chrome 5+特点：永久存储，不会被爬虫爬到，值类型限定为string，只在本地生效读:localStorage.getItem(‘name’)localStorage.namelocalStorage.key(‘name’) //通过key值获取删：localStorage.removeItem(‘name’)检测是否存在某个变量：localStorage.hasOwnProperty(‘name’) //hasOwnProperty为对象的方法，可以用来检测一个对象是否含有特定的自身属性 sessionStorage与localStorage不同之处：1.临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据2.同源策略限制。若想在不同页面之间对同一个sessionStorage进行操作，这些页面必须在同一协议、同一主机名和同一端口下。(IE 8和9存储数据仅基于同一主机名，忽略协议（HTTP和HTTPS）和端口号的要求)3.sessionStorage操作限制在单个标签页中，在此标签页进行同源页面访问都可以共享sessionStorage数据 三.离线web应用页面缓存指的还是有网络状态下，而离线web应用指的是在没有网络状态可以运行应用 检测是否支持： .theirs]]></content>
  </entry>
  <entry>
    <title><![CDATA[js非构造函数继承（持续更新）]]></title>
    <url>%2F2018%2F10%2F23%2F20181023-1%2F</url>
    <content type="text"><![CDATA[背景昨天整理了一下js含构造函数的对象实现继承的方式，今天整理下非构造函数的继承 方法1.object方法json格式的发明人Douglas Crockford，提出了一个object()函数123456789101112131415161718function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;实例var Chinese = &#123; nation:'中国'&#125;;var Doctor = &#123; career:'医生'&#125;Doctor = object(Chinese);console.log(Doctor.nation) //中国 2.浅拷贝把父对象的属性拷贝给子对象，实现继承 123456789101112function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125;结果var Doctor = extendCopy(Chinese);Doctor.career = '医生';alert(Doctor.nation); // 中国 这样的做法存在一个问题，如果父元素的属性中存在数组或者对象，拷贝过来的只是一个内存地址指向 123456789如果给chinese对象添加一条属性Chinese.birthPlaces = ['北京','上海','香港'];var Doctor = extendCopy(Chinese);Doctor.birthPlace.push('厦门');console.log(chinese.birthPlace) //['北京','上海','香港','厦门'] 如果修改Doctor.birthPlace,内存地址指向的数组被修改,chinese中的birthPlace也被修改，显然不符合预期 3.深拷贝递归调用浅拷贝，即可实现深拷贝1234567891011121314151617function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125;var Doctor = deepCopy(Chinese);Chinese.birthPlaces = ['北京','上海','香港'];Doctor.birthPlaces.push('厦门');alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港 深拷贝后，birthPlace属性在doctor中就是独立存在的一个属性，而不是一个内存指向了，所以对doctor的任何操作都不会对chinese有任何影响]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js构造函数的继承（持续更新）]]></title>
    <url>%2F2018%2F10%2F22%2F20181022-1%2F</url>
    <content type="text"><![CDATA[背景最近复习js基本原理，毕竟什么框架都是建立在js的基础上的，js精通，框架又有何难。趁着有时间整理一下js实现继承的方式。 具体方式1.构造函数绑定最简单，使用call和apply，将父对象的构造函数绑定到子对象身上 1234567891011function Animal()&#123; this.species = "动物";&#125;function cat(name,color)&#123; Animal.call(this,arguments); this.name = name; this.color = color;&#125;var cat1 = new cat('大毛','红色');console.log(cat1.species) 2.prototype模式将cat的prototype指向Animal实例，那么所有的cat对象都拥有animal的属性，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向cat的；加了这一行以后，cat.prototype.constructor指向Animal。 每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！cat实例是由构造函数cat生成的，为了保证继承链的稳定，手动纠正，将constructor指回cat123456789101112131415161718function Animal()&#123; this.species = "动物";&#125;function cat(name,color)&#123; this.name = name; this.color = color;&#125;cat.prototype = new Animal();cat.prototype.constructor = cat;var cat1 = new cat("大毛","黄色");alert(cat1.species); // 动物如果没有将constructor手动纠正，那么cat1.prototype.constructor = Animal;纠正后cat1.prototype.constructor = cat; 3.利用空对象做中介1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;cat.prototype = new F();cat.prototype.constructor = Cat; F是空对象，所以几乎不占内存。这时，修改cat的prototype对象，就不会影响到Animal的prototype对象。 将上述操作进行封装12345678910function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = new Parent(); Child.prototype = new F(); Child.prototype.constructor = Child;&#125;使用extend(cat,animal);cat继承animal属性 4.拷贝继承原理为，将父对象所有属性拷贝进字对象实现继承。12345678function extend2(child,parent)&#123; var p = new parent(); var c = child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125;&#125;extend2(cat, animal);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中五种检测数据类型方法]]></title>
    <url>%2F2018%2F10%2F19%2F20181019-1%2F</url>
    <content type="text"><![CDATA[背景最近公司项目不多，静下心来整理一些东西（不加班的feel倍儿爽）。js判断数据类型算是很常用的代码了，不管是项目中还是面试，必不可少啊，值得一记。 方法1.typeOftypeOf 为一个一元运算符，放在一个运算数之前，运算数可以是任何类型。返回结果为一个字符串，该字符串对应运算数的数据类型。 用法：typeOf + 运算数 或 typeOf (运算数) 结果展示：12345678910typeof Symbol(); // symbol 有效，symbol为es6中第七种数据类型typeof ''; // string 有效typeof 1; // number 有效typeof true; //boolean 有效typeof undefined; //undefined 有效typeof new Function(); // function 有效typeof null; //object 无效typeof [] ; //object 无效typeof new Date(); //object 无效typeof new RegExp(); //object 无效 注意：typeof null 的问题不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“ object ”,typeOf对null束手无策。 typeOf [] 的问题JS中因为数组也是属于对象的，所以判断是不是数组，typeOf表示：不好办啊 同理，日期类型Date()和正则表达式RegExp() 也是属于对象,所以Date()/RegExp()/[]/null 不能用typeOf来检测 2.instanceof用法： object instanceof constructor instanceof 同为一元运算符，用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性 看起来比较绕，上例子12var a = new Array();a instanceof Array; instanceof 可以检测 某个对象是否为数组、日期、regexp() 类型 注意：因为undefined 和null 类型，访问不到内部，所以不能用instanceof判断 3.constructorconstructor作用和instanceof非常相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。 12345678var a = 'abc';a.constructor===String;//truea.constructor===Array;//falsea.constructor===RegExp;//false(1).constructor===Number;//truevar reg = /[0-9]/;reg.constructor===RegExp;//truereg.constructor===Object;//false 注意：1.constructor 不能用于判断null和undefined （不存在constructor）2.如果object被重新覆盖，检测结果就会不准确 4.严格运算符 ===只能用于判断null 和 undefined 123var a = nulltypeof a // "object"a === null // true 5.Object.prototype.toString.call()这个方法就比较花里胡哨了，在以前的项目中也基本没用过这个方式。 toString方法，在Object原型上的返回，是数据的格式。因为不同类型的toString方法，都被重写。所以obj.toString和Object.prototype.toString.call(obj)的结果不同。 优点：可以判断所有类型缺点：得到的结果为’[object String]’类型的字符串，需要处理一下格式。 12345678910console.log(Object.prototype.toString.call("jerry"));//[object String]console.log(Object.prototype.toString.call(12)); //[object Number]console.log(Object.prototype.toString.call(true)); //[object Boolean]console.log(Object.prototype.toString.call(undefined));//[object Undefined]console.log(Object.prototype.toString.call(null)); //[object Null]console.log(Object.prototype.toString.call(&#123;name: "jerry"&#125;));//[object Object]console.log(Object.prototype.toString.call(function()&#123;&#125;)); //[object Function]console.log(Object.prototype.toString.call([])); //[object Array]console.log(Object.prototype.toString.call(new Date)); //[object Date]console.log(Object.prototype.toString.call(/\d/)); //[object RegExp] 总结综上，可以得出结论 Symbol、string、number、boolean、function、undefined 使用 typeOf() null、[]、obj、Date()、RegExp() 使用instanceof 或者所有的类型检测都用Object.prototype.toString.call(),更有逼格。 即可做到正确检测。就酱。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git生成公钥]]></title>
    <url>%2F2018%2F10%2F17%2F20181017-1%2F</url>
    <content type="text"><![CDATA[背景在coding上部署hexo博客过程中产生git生成公钥的需求，然后搜索用法，发现搜索到好多垃圾信息，真的是浪费时间，特此记录。 获取方式任意文件夹，右键菜单打开git Bash（在安装了git的情况下），输入命令 1ssh-keygen -t rsa -C "example@163.com" 邮箱自定 一路回车（应该是3下），最后提示，the key’s randomart image is，下边一个字符组成的正方形，说明公钥已经生成了。打开 文件目录C:\Users\你的用户名，发现有两个文件id_rsa.pub和id_rsa，将id_rsa.pub拖入编辑器（本人用vscode，可以打开），是一串ssh-rsa开头的字符。这个就是字符的公钥了。]]></content>
      <tags>
        <tag>git用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序按钮去除边框]]></title>
    <url>%2F2018%2F10%2F16%2F20181016-1%2F</url>
    <content type="text"><![CDATA[背景前阵子，入手微信小程序的开发，就发现，相比于vue简单很多。api文档简洁明了，基本上人家文档上写的就能直接用，文档上没写的，80%就没法实现，省了不少调研的工作。记录一下开发中碰到的一些不容易注意到的地方，仅供参考。 出现的问题小程序自带button标签，默认情况下，是自带边框的。项目中需要按钮自定义边框样式或者没有边框的时候，就发现12345button&#123; border:none; outline:none; border:0;&#125; 这三种方式，都不行，哇，就很难受 解决方案后来研究发现，button的标签，样式是定义在::after伪元素上的（官方压根没提，或者是我没看到吧）12345button::after&#123; border:none; outline:none; border:0;&#125; 这样就搞定了虽然这个问题也不难,但是了解一下还是能节省点开发的时间的，就酱]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博大吉]]></title>
    <url>%2F2018%2F09%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[新博开张，大吉大利！Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>
